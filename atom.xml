<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Effective TypeScript</title>
  <icon>https://effectivetypescript.com/icon.png</icon>
  <subtitle>62 Specific Ways to Improve Your TypeScript</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://effectivetypescript.com/"/>
  <updated>2020-06-16T14:55:40.510Z</updated>
  <id>https://effectivetypescript.com/</id>
  
  <author>
    <name>Dan Vanderkam</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Use typed identity functions to guide type inference</title>
    <link href="https://effectivetypescript.com/2020/06/16/typed-identity-functions/"/>
    <id>https://effectivetypescript.com/2020/06/16/typed-identity-functions/</id>
    <published>2020-06-16T15:00:00.000Z</published>
    <updated>2020-06-16T14:55:40.510Z</updated>
    
    <content type="html"><![CDATA[<p>TypeScript tends to do a very good job of inferring types when you leave off explicit annotations. (Chapter 3 of <a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://amzn.to/38s1oCK'); return false;"><em>Effective TypeScript</em></a> is devoted to this topic.) But when you use tuples or string literal types, this will sometimes go wrong. This post explores using identity functions with carefully constructed type signatures to guide inference towards alternative types. <a id="more"></a></p><p>Say you have a function to calculate the <a href="https://en.wikipedia.org/wiki/Pythagorean_theorem" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://en.wikipedia.org/wiki/Pythagorean_theorem'); return false;">distance between two points</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Point = [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>];<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dist</span>(<span class="hljs-params">[x1, y1]: Point, [x2, y2]: Point</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.sqrt((x2 - x1) ** <span class="hljs-number">2</span> + (y2 - y1) ** <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>If you define some points and try to call this function, you&#39;ll get an error:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> p1 = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>];<br><span class="hljs-keyword">const</span> p2 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> d = dist(p1, p2);<br><span class="hljs-comment">//           ~~ Argument of type 'number[]' is not assignable</span><br><span class="hljs-comment">//                to parameter of type 'Point'.</span><br><span class="hljs-comment">//              Type 'number[]' is missing the following properties</span><br><span class="hljs-comment">//                from type '[number, number]': 0, 1 (2345)</span><br></code></pre></td></tr></table></figure><p>The issue is that TypeScript has inferred the types of <code>p1</code> and <code>p2</code> as <code>number[]</code>, whereas you would have preferred <code>Point</code>. These aren&#39;t compatible (there are many number arrays that aren&#39;t <code>Point</code>s) and hence the error.</p><p>There are a whole class of type errors like this that happen when the inferred type wasn&#39;t quite the one you had in mind. In this case the easiest solution is to either declare the type of each point:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> p1: Point = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>];<br><span class="hljs-keyword">const</span> p2: Point = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> d = dist(p1, p2);  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>or use a &quot;const assertion&quot; to avoid inferring the wider types:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> p1 = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;<br><span class="hljs-keyword">const</span> p2 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;<br><span class="hljs-keyword">let</span> d = dist(p1, p2);  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>In this case the inferred types are much narrower than <code>Point</code>, but they are assignable to <code>Point</code>, so this type checks.</p><p>But in this post I want to talk about a slightly different approach, which is to use identity functions that adjust the inferred type. Here&#39;s one way you could use an identity(ish) function to get a <code>Point</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> Point = (x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">Point</span> =&gt;</span> [x, y];<br><br><span class="hljs-keyword">const</span> p1 = Point(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">const</span> p2 = Point(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br><span class="hljs-keyword">let</span> d = dist(p1, p2);  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>The <code>Point</code> function is a value, so it&#39;s fine that it has the same name as the <code>Point</code> type, which exists in a separate namespace (Item 8 in <a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://amzn.to/38s1oCK'); return false;"><em>Effective TypeScript</em></a> discusses how to know if a symbol is in type or value space). The &quot;<code>: Point</code>&quot; declares the return type of the function. This is preferable to <code>as Point</code>, which <a href="https://stackoverflow.com/questions/41964087/in-typescript-is-there-a-reason-to-prefer-const-foo-type-or-const-foo" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://stackoverflow.com/questions/41964087/in-typescript-is-there-a-reason-to-prefer-const-foo-type-or-const-foo'); return false;">would not perform excess property checking</a>.</p><p>This certainly solves the problem and is sometimes more convenient than using declarations. Examples of this pattern in the wild include Material-UI&#39;s <a href="https://material-ui.com/guides/typescript/#using-createstyles-to-defeat-type-widening" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://material-ui.com/guides/typescript/#using-createstyles-to-defeat-type-widening'); return false;"><code>createStyles</code></a> and React Native&#39;s <a href="https://reactnative.dev/docs/style" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://reactnative.dev/docs/style'); return false;"><code>StyleSheet.create</code></a>.</p><p>In the case of a tuple, though, there&#39;s a neat trick (which I learned from Boris Cherny&#39;s <a href="https://www.amazon.com/Programming-TypeScript-Making-JavaScript-Applications/dp/1492037656" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://www.amazon.com/Programming-TypeScript-Making-JavaScript-Applications/dp/1492037656'); return false;"><em>Programming TypeScript</em></a>) to solve this more generally. You can use a generic identity function to get TypeScript to infer a tuple type, rather than an array:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> tuple = &lt;T <span class="hljs-keyword">extends</span> unknown[]&gt;(...args: T): <span class="hljs-function"><span class="hljs-params">T</span> =&gt;</span> args;<br><br><span class="hljs-keyword">const</span> p1 = tuple(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">const</span> p2 = tuple(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br><span class="hljs-keyword">let</span> d = dist(p1, p2);  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>If you mouse over <code>p1</code> or <code>p2</code> <a href="https://www.typescriptlang.org/play/#code/C4TwDgpgBACg9gSwHbCgXigbSQVwLYBGEATgDRS6EkC6A3AFABmOSAxsAnElACYIDOwABSYAHgEZyIcdQBcsRCnJiATFJVyFyYAEooAb3pRjUYhGA5i3ALIBDYAAsAdPwCOxYUNEqoAWigSegBUQVA+ANRQQiA+-tLBoSo6DAC+9PSsXIJQFmAANtAYADwAKlAQosAQSDz8UCwA1khwAO5ImNQAfEJOvbbEAOb88iU6I+idUP1DDBlZqGDi6Dk4+RBCAAzkG8nGAPR7OeDQAliURGQU+BfUc0jZYD4YuQVCAMzkACy7UAdHkFBTthriRyOcaPQCqgeMs+IIhItyI8fn84A16EA" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://www.typescriptlang.org/play/#code/C4TwDgpgBACg9gSwHbCgXigbSQVwLYBGEATgDRS6EkC6A3AFABmOSAxsAnElACYIDOwABSYAHgEZyIcdQBcsRCnJiATFJVyFyYAEooAb3pRjUYhGA5i3ALIBDYAAsAdPwCOxYUNEqoAWigSegBUQVA+ANRQQiA+-tLBoSo6DAC+9PSsXIJQFmAANtAYADwAKlAQosAQSDz8UCwA1khwAO5ImNQAfEJOvbbEAOb88iU6I+idUP1DDBlZqGDi6Dk4+RBCAAzkG8nGAPR7OeDQAliURGQU+BfUc0jZYD4YuQVCAMzkACy7UAdHkFBTthriRyOcaPQCqgeMs+IIhItyI8fn84A16EA'); return false;">in the playground</a>, you&#39;ll see that its type has been inferred as <code>[number, number]</code>, just like we wanted.</p><p>This works with any sort of tuples, including those with mixed types:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-string">'two'</span>, <span class="hljs-regexp">/three/</span>]; <span class="hljs-comment">// type is (number|string|RegExp)[]</span><br><span class="hljs-keyword">const</span> tup = tuple(<span class="hljs-number">1</span>, <span class="hljs-string">'two'</span>, <span class="hljs-regexp">/three/</span>); <span class="hljs-comment">// type is [number, string, RegExp]</span><br></code></pre></td></tr></table></figure><p>The <code>tuple</code> function isn&#39;t one you&#39;d write in plain JavaScript (it&#39;s shorter to use an array literal), but in the TypeScript context it becomes an extremely useful way to change up the inferred type.</p><p>You can apply the same idea if you want to let TypeScript infer the keys of an object but still provide an explicit type for the values. For example:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> capitals = &#123;<br>  ny: [<span class="hljs-number">-73.7562</span>, <span class="hljs-number">42.6526</span>],<br>  ca: [<span class="hljs-number">-121.4944</span>, <span class="hljs-number">38.5816</span>],<br>  ak: [<span class="hljs-number">-134.4197</span>, <span class="hljs-number">58.3019</span>],<br>&#125;;<br></code></pre></td></tr></table></figure><p>If you try to calculate the distance between two capitals, you&#39;ll get the same error as before:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">dist(capitals.ny, capitals.ak);<br><span class="hljs-comment">//   ~~~~~~~~~~~ Argument of type 'number[]' is not assignable</span><br><span class="hljs-comment">//                 to parameter of type 'Point'</span><br></code></pre></td></tr></table></figure><p>(To calculate the actual distance you should use something like <a href="https://turfjs.org/docs/#distance" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://turfjs.org/docs/#distance'); return false;"><code>turf.distance</code></a>.)</p><p>Mousing over <code>capitals</code>, you&#39;ll see its type is inferred as <code>{ny: number[]; ca: number[]; ak: number[];}</code>. You could wrap all the capital locations in <code>tuple</code> like before, but let&#39;s try writing a different identity function to force them all to be <code>Point</code>s:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> withValueType = &lt;V <span class="hljs-keyword">extends</span> unknown&gt;<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span><br>  &lt;T <span class="hljs-keyword">extends</span> Record&lt;PropertyKey, V&gt;&gt;<span class="hljs-function">(<span class="hljs-params">o: T</span>) =&gt;</span> o;<br><br><span class="hljs-keyword">const</span> capitals = withValueType&lt;Point&gt;()(&#123;<br>  ny: [<span class="hljs-number">-73.7562</span>, <span class="hljs-number">42.6526</span>],<br>  ca: [<span class="hljs-number">-121.4944</span>, <span class="hljs-number">38.5816</span>],<br>  ak: [<span class="hljs-number">-134.4197</span>, <span class="hljs-number">58.3019</span>],<br>&#125;);<br><br>d = dist(capitals.ny, capitals.ak);  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>If you mouse over the type of <code>capitals</code> now, it&#39;s</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> capitals: &#123;<br>    ny: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>];<br>    ca: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>];<br>    ak: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>and the types all work out!</p><p>So how does <code>withValueType</code> work? In order to infer the object&#39;s type as something different, we first need to capture it in a generic argument, just like we did with <code>tuple</code>. This is <code>T</code>, and we want TypeScript to infer it. We also want to explicitly write the value type <code>V</code> (<code>Point</code> in this case). Unfortunately you can&#39;t have a function with one explicit generic parameter and one inferred parameter. TypeScript will either infer all the generic parameters to a function or none of them, <a href="https://github.com/Microsoft/TypeScript/issues/14400" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://github.com/Microsoft/TypeScript/issues/14400'); return false;">not a mix</a>.</p><p>There is a standard workaround for this problem: split the function into two, one with an explicit generic parameter and one with an inferred parameter. Instead of an identity function, we now have a function that <em>returns</em> an identity function. (Note the extra <code>()</code> after <code>withValueType</code>!)</p><p>It&#39;s important to note that this is quite different than using an <a href="https://www.typescriptlang.org/docs/handbook/interfaces.html#indexable-types" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://www.typescriptlang.org/docs/handbook/interfaces.html#indexable-types'); return false;">index type</a> or <code>Record</code>, which also fixes the type error:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// (Don't do this, see below!)</span><br><span class="hljs-keyword">const</span> capitalsRec: Record&lt;<span class="hljs-built_in">string</span>, Point&gt; = &#123;<br>  ny: [<span class="hljs-number">-73.7562</span>, <span class="hljs-number">42.6526</span>],<br>  ca: [<span class="hljs-number">-121.4944</span>, <span class="hljs-number">38.5816</span>],<br>  ak: [<span class="hljs-number">-134.4197</span>, <span class="hljs-number">58.3019</span>],<br>&#125;;<br><br>d = dist(capitalsRec.ny, capitalsRec.ak);  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>The difference is that accessing an invalid key produces an error when you let TypeScript infer the keys, but not when you use an index type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">capitalsRec.in;  <span class="hljs-comment">// allowed</span><br>capitals.in;<br>      <span class="hljs-comment">// ~~ Property 'in' does not exist on type ...</span><br></code></pre></td></tr></table></figure><p>The inferred type of <code>capitals</code> is more like <code>Record&lt;&#39;ny&#39;|&#39;ca&#39;|&#39;ak&#39;, Point&gt;</code> than <code>Record&lt;string, Point&gt;</code>. But because the keys were inferred, you didn&#39;t have to write <code>&#39;ny&#39;|&#39;ca&#39;|&#39;ak&#39;</code> explicitly.</p><p>As a final example, you may find that you want to define an object that has some (but not all) of the fields of another object.</p><p>For example:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> CSSColor = <span class="hljs-string">'aliceblue'</span> | <span class="hljs-string">'antiquewhite'</span> | <span class="hljs-string">'aqua'</span> | <span class="hljs-string">'aquamarine'</span> <span class="hljs-comment">// | ...;</span><br><span class="hljs-keyword">interface</span> DisplayValue &#123;<br>  value: <span class="hljs-built_in">number</span>;<br>  units: <span class="hljs-built_in">string</span>;<br>  color: CSSColor;<br>  style: <span class="hljs-string">'regular'</span> | <span class="hljs-string">'bold'</span> | <span class="hljs-string">'italic'</span> | <span class="hljs-string">'bolditalic'</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> defaults = &#123;<br>  color: <span class="hljs-string">'black'</span>,<br>  style: <span class="hljs-string">'regular'</span>,<br>&#125;;<br><br><span class="hljs-keyword">const</span> distanceToJupiter: DisplayValue = &#123;<br>   <span class="hljs-comment">// ~~~~~~~~~~~~~~~~~</span><br>   <span class="hljs-comment">// Type is not assignable to type 'DisplayValue'.</span><br>   <span class="hljs-comment">//   Types of property 'color' are incompatible.</span><br>   <span class="hljs-comment">//     Type 'string' is not assignable to type 'CSSColor'.</span><br>  ...defaults,<br>  value: <span class="hljs-number">25</span>_259_974_097_204,<br>  units: <span class="hljs-string">'inches'</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>What went wrong? Despite the error on <code>distanceToJupiter</code>, the problem is with <code>defaults</code>. Its type is inferred as <code>{ color: string; style: string; }</code>, rather than the narrower value types required for a <code>DisplayValue</code>.</p><p>You might try to solve the problem by using <code>Partial</code> in the declaration of <code>defaults</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> defaults: Partial&lt;DisplayValue&gt; = &#123;<br>  color: <span class="hljs-string">'black'</span>,<br>  style: <span class="hljs-string">'regular'</span>,<br>&#125;;<br><br><span class="hljs-keyword">const</span> distanceToJupiter: DisplayValue = &#123;<br>   <span class="hljs-comment">// ~~~~~~~~~~~~~~~~~</span><br>   <span class="hljs-comment">// ... Type 'undefined' is not assignable to type 'CSSColor'.</span><br>  ...defaults,<br>  value: <span class="hljs-number">25</span>_259_974_097_204,<br>  units: <span class="hljs-string">'inches'</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>Now the issue is that you&#39;ve lost the specificity of the keys in <code>defaults.</code> The <code>Partial&lt;DisplayValue&gt;</code> type marks <em>all</em> the properties as optional, including <code>color</code> and <code>style</code> which you&#39;ve definitely specified. Hence the error about <code>undefined</code>.</p><p>You can&#39;t solve this using <code>withValueType</code> since the values for <code>color</code> and <code>style</code> have different types. Instead, you can craft a slightly different generic identity function. I call this <code>withValueTypesFrom</code>, since you&#39;re taking the value types from some other type (if you have a better name, please suggest it!):</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> withValueTypesFrom = &lt;V <span class="hljs-keyword">extends</span> unknown&gt;<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span><br>    &lt;K <span class="hljs-keyword">extends</span> keyof V&gt;(x: Pick&lt;V, K&gt;): Pick&lt;V, K&gt; =&gt; x;<br><br><span class="hljs-keyword">const</span> defaults = withValueTypesFrom&lt;DisplayValue&gt;()(&#123;<br>  color: <span class="hljs-string">'black'</span>,<br>  style: <span class="hljs-string">'regular'</span>,<br>&#125;);  <span class="hljs-comment">// Type is Pick&lt;DisplayValue, "color" | "style"&gt;</span><br><br><span class="hljs-keyword">const</span> distanceToJupiter: DisplayValue = &#123;<br>  ...defaults,<br>  value: <span class="hljs-number">25</span>_259_974_097_204,<br>  units: <span class="hljs-string">'inches'</span>,<br>&#125;;  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>It&#39;s worth repeating that none of the values have changed here, just the types. This has all the right properties: if you specify an invalid color in <code>defaults</code>, you&#39;ll get an error. If you misspell <code>color</code> as <code>colour</code>, you&#39;ll get an error. And if you leave out <code>value</code> or <code>units</code> in <code>distanceToJupiter</code>, you&#39;ll also get an error.</p><p>TypeScript tends to do a very good job of inferring types when you leave off explicit annotations. But when you use tuples or string literal types, this will sometimes go wrong. When this happens, type declarations or const assertions are typically the answer. But if you want to adjust inference in more general or complex ways, typed identity functions give you the flexibility to do so.</p><p>Do you have other examples of functions that help with inference? Chime in in the comments! You can find the full code from this example on the <a href="https://www.typescriptlang.org/play/?ssl=52&ssc=7&pln=52&pc=20#code/C4TwDgpgBACg9gSwHbCgXigbSQVwLYBGEATgDRS6EkC6A3AFABmOSAxsAnElACYIDOwABSYAHgEZyIcdQBcsRCnJiATFJVyFyYAEooAb3pRjUYhGA5i3ALIBDYAAsAdPwCOxYUNEqoAWigSegBUQVA+ANRQQiA+-tLBoSo6DAC+9PSsXIJQFmAANtAYADwAKlAQosAQSDz8UCwA1khwAO5ImNQAfEJOvbbEAOb88iU6I+idUP1DDBlZqGDi6Dk4+RBCAAzkG8nGAPR7OeDQAliURGQU+BfUc0jZYD4YuQVCAMzkACy7UAdHkFBTthriRyOcaPQCqgeMs+IIhItyI8fn84A10pl7qh+sRlphJFAAOTAFpwQnkPaOMwQPZ0X6HUAA05CcHEAA+gmIyAGbIAShABhUdB07tlcssXusCcTSeTflSIDTdn9GSc6sCqJdOdzyPzBaJbqLUC0EI4AGq2PI4CAlY7LIpm8qVaq1epIJqtJDdPRoSalJ1VGp1fmZYg8IowYhwSAeEAAaQgIHIZs63TgIx9kzgs0x2VYtjApstdQwJvNluttsgEcUwG9QkMxiQIHkmF8AHY3k52wBWABsaignxUTj7PZUfeopCMUHzrd84hU4icnwAnJ9PuQ3gAOJw97fiSfT4y2Brz8RvT4r8Sr9vkfdON4bG9T+gpZLpGEYOHCfOF4DFk4zbkH+RZ5PwTinh+fwmCYAB+CGIUhcFQAAgoM+DVKgcCMP80CEqyHSEoCdTNNi-D8AgAxILYBAFPQMGwUxzGwcAcBQGA-S2Hg5gkFAOF4US8DaISGLzLOyyNhQLZYB2Xa9gOXwjmOE6vsYc6yYuy5rhuW67vuh5qVMZ6aZe163veu5Pi+04pDm4mgQB4EhvIIZwGGRTakgAzkMJKCTBgUnNvOnbdv2g7DqO45HjOGltlpK7rpuUA7nuB4xSeJnxWZnw3neUAPtZq6vnZGIFmB-Ahk4yAMI5gE1TOsF-AhsBRjGoBEsgxE8HAECkXAqAVAI2HcKqUC9E46RjQAwgAyrN01wHk7nLISloIKwEB0daxFskStgoAgrjWi0DimhAu37cdtiXWt114P0yAXVAe2EnRtisA0xF-HtE0MNoJCMB90AACICPktggBaVrQFJABuFYQPIrIMMYLCmsMUBeQMqOzkt7nyHNC348QuOCCABTyISZgDDgeT9LdBBLTwt1gRtjPM2zrCEqk6R-LmqDIIwJAwBtDT2o6FSBq6jTNG03oTFA-pSy6dQwP0HCWg6qZCOmUCjIr2ZGlAZYOND1r8FWfUAGJRngEsBqrboevLQiZo1Stxo7QZQA0iYCSmXjyKLn0OuQcadGMsBi2HUAR4roj2VivAQEDdPACWJummbiOW8c-C23AeBFGD-AQ1DiP1lJmTLcQVPvZ95IzuTlNEjTdMM7ZH7Gz+B2bSUcAAFKrOdddQKX5fm4UBgzhNPCp7Y6f8MeUAIzD8gqD2AD6m+rlvt6fFvGy3jvGybjO6MZ1TyCsA4fVN6VQA" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://www.typescriptlang.org/play/?ssl=52&ssc=7&pln=52&pc=20#code/C4TwDgpgBACg9gSwHbCgXigbSQVwLYBGEATgDRS6EkC6A3AFABmOSAxsAnElACYIDOwABSYAHgEZyIcdQBcsRCnJiATFJVyFyYAEooAb3pRjUYhGA5i3ALIBDYAAsAdPwCOxYUNEqoAWigSegBUQVA+ANRQQiA+-tLBoSo6DAC+9PSsXIJQFmAANtAYADwAKlAQosAQSDz8UCwA1khwAO5ImNQAfEJOvbbEAOb88iU6I+idUP1DDBlZqGDi6Dk4+RBCAAzkG8nGAPR7OeDQAliURGQU+BfUc0jZYD4YuQVCAMzkACy7UAdHkFBTthriRyOcaPQCqgeMs+IIhItyI8fn84A10pl7qh+sRlphJFAAOTAFpwQnkPaOMwQPZ0X6HUAA05CcHEAA+gmIyAGbIAShABhUdB07tlcssXusCcTSeTflSIDTdn9GSc6sCqJdOdzyPzBaJbqLUC0EI4AGq2PI4CAlY7LIpm8qVaq1epIJqtJDdPRoSalJ1VGp1fmZYg8IowYhwSAeEAAaQgIHIZs63TgIx9kzgs0x2VYtjApstdQwJvNluttsgEcUwG9QkMxiQIHkmF8AHY3k52wBWABsaignxUTj7PZUfeopCMUHzrd84hU4icnwAnJ9PuQ3gAOJw97fiSfT4y2Brz8RvT4r8Sr9vkfdON4bG9T+gpZLpGEYOHCfOF4DFk4zbkH+RZ5PwTinh+fwmCYAB+CGIUhcFQAAgoM+DVKgcCMP80CEqyHSEoCdTNNi-D8AgAxILYBAFPQMGwUxzGwcAcBQGA-S2Hg5gkFAOF4US8DaISGLzLOyyNhQLZYB2Xa9gOXwjmOE6vsYc6yYuy5rhuW67vuh5qVMZ6aZe163veu5Pi+04pDm4mgQB4EhvIIZwGGRTakgAzkMJKCTBgUnNvOnbdv2g7DqO45HjOGltlpK7rpuUA7nuB4xSeJnxWZnw3neUAPtZq6vnZGIFmB-Ahk4yAMI5gE1TOsF-AhsBRjGoBEsgxE8HAECkXAqAVAI2HcKqUC9E46RjQAwgAyrN01wHk7nLISloIKwEB0daxFskStgoAgrjWi0DimhAu37cdtiXWt114P0yAXVAe2EnRtisA0xF-HtE0MNoJCMB90AACICPktggBaVrQFJABuFYQPIrIMMYLCmsMUBeQMqOzkt7nyHNC348QuOCCABTyISZgDDgeT9LdBBLTwt1gRtjPM2zrCEqk6R-LmqDIIwJAwBtDT2o6FSBq6jTNG03oTFA-pSy6dQwP0HCWg6qZCOmUCjIr2ZGlAZYOND1r8FWfUAGJRngEsBqrboevLQiZo1Stxo7QZQA0iYCSmXjyKLn0OuQcadGMsBi2HUAR4roj2VivAQEDdPACWJummbiOW8c-C23AeBFGD-AQ1DiP1lJmTLcQVPvZ95IzuTlNEjTdMM7ZH7Gz+B2bSUcAAFKrOdddQKX5fm4UBgzhNPCp7Y6f8MeUAIzD8gqD2AD6m+rlvt6fFvGy3jvGybjO6MZ1TyCsA4fVN6VQA'); return false;">TypeScript playground</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TypeScript tends to do a very good job of inferring types when you leave off explicit annotations. (Chapter 3 of &lt;a href=&quot;https://amzn.to/38s1oCK&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; onclick=&quot;trackOutboundLink(&#39;&#39;, &#39;https://amzn.to/38s1oCK&#39;); return false;&quot;&gt;&lt;em&gt;Effective TypeScript&lt;/em&gt;&lt;/a&gt; is devoted to this topic.) But when you use tuples or string literal types, this will sometimes go wrong. This post explores using identity functions with carefully constructed type signatures to guide inference towards alternative types.
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Item 54: Know How to Iterate Over Objects</title>
    <link href="https://effectivetypescript.com/2020/05/26/iterate-objects/"/>
    <id>https://effectivetypescript.com/2020/05/26/iterate-objects/</id>
    <published>2020-05-26T13:30:45.000Z</published>
    <updated>2020-05-26T13:29:01.610Z</updated>
    
    <content type="html"><![CDATA[<p><em>Iterating over the keys and values in an object is a common operation that&#39;s surprisingly hard to write without type assertions in TypeScript. The difficulty results from a combination of the <a href="https://medium.com/node-modules/what-is-prototype-pollution-and-why-is-it-such-a-big-deal-2dd8d89a93c" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://medium.com/node-modules/what-is-prototype-pollution-and-why-is-it-such-a-big-deal-2dd8d89a93c'); return false;">quirks</a> of JavaScript objects and <a href="https://www.typescriptlang.org/docs/handbook/interfaces.html" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://www.typescriptlang.org/docs/handbook/interfaces.html'); return false;">duck typing</a>. Reading through this item again, I&#39;d add that this is all a good reason to consider using an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map'); return false;">ES6 <code>Map</code></a> instead of an object to store key/value pairs!</em></p><p>This code runs fine, and yet TypeScript flags an error in it. Why?</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> obj = &#123;<br>  one: <span class="hljs-string">'uno'</span>,<br>  two: <span class="hljs-string">'dos'</span>,<br>  three: <span class="hljs-string">'tres'</span>,<br>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> k <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-keyword">const</span> v = obj[k];<br>         <span class="hljs-comment">// ~~~~~~ Element implicitly has an 'any' type</span><br>         <span class="hljs-comment">//        because type ... has no index signature</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Inspecting the <code>obj</code> and <code>k</code> symbols gives a clue:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><span class="hljs-comment">// const obj: &#123;</span><br><span class="hljs-comment">//     one: string;</span><br><span class="hljs-comment">//     two: string;</span><br><span class="hljs-comment">//     three: string;</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> k <span class="hljs-keyword">in</span> obj) &#123;  <span class="hljs-comment">// const k: string</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>The type of <code>k</code> is <code>string</code>, but you&#39;re trying to index into an object whose type only has three specific keys: <code>&#39;one&#39;</code>, <code>&#39;two&#39;</code>, and <code>&#39;three&#39;</code>. There are strings other than these three, so this has to fail.</p><p>Plugging in a narrower type declaration for <code>k</code> fixes the issue:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> k: keyof <span class="hljs-keyword">typeof</span> obj;  <span class="hljs-comment">// Type is "one" | "two" | "three"</span><br><span class="hljs-keyword">for</span> (k <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-keyword">const</span> v = obj[k];  <span class="hljs-comment">// OK</span><br>&#125;<br></code></pre></td></tr></table></figure><p>So the real question is: why is the type of <code>k</code> in the first example inferred as <code>string</code> rather than <code>&quot;one&quot; | &quot;two&quot; | &quot;three&quot;</code>?</p><p>To understand, let&#39;s look at a slightly different example involving an interface and a function:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> ABC &#123;<br>  a: <span class="hljs-built_in">string</span>;<br>  b: <span class="hljs-built_in">string</span>;<br>  c: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">abc: ABC</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> k <span class="hljs-keyword">in</span> abc) &#123;  <span class="hljs-comment">// const k: string</span><br>    <span class="hljs-keyword">const</span> v = abc[k];<br>           <span class="hljs-comment">// ~~~~~~ Element implicitly has an 'any' type</span><br>           <span class="hljs-comment">//        because type 'ABC' has no index signature</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>It&#39;s the same error as before. And you can &quot;fix&quot; it using the same sort of declaration (<code>let k: keyof ABC</code>). But in this case TypeScript is right to complain. Here&#39;s why:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> x = &#123;a: <span class="hljs-string">'a'</span>, b: <span class="hljs-string">'b'</span>, c: <span class="hljs-number">2</span>, d: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()&#125;;<br>foo(x);  <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><p>The function <code>foo</code> can be called with any value <em>assignable</em> to <code>ABC</code>, not just a value with &quot;a,&quot; &quot;b,&quot; and &quot;c&quot; properties. It&#39;s entirely possible that the value will have other properties, too (see Item 4: Get Comfortable with Structural Typing). To allow for this, TypeScript gives <code>k</code> the only type it can be confident of, namely, <code>string</code>.</p><p>Using the <code>keyof</code> declaration would have another downside here:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">abc: ABC</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> k: keyof ABC;<br>  <span class="hljs-keyword">for</span> (k <span class="hljs-keyword">in</span> abc) &#123;  <span class="hljs-comment">// let k: "a" | "b" | "c"</span><br>    <span class="hljs-keyword">const</span> v = abc[k];  <span class="hljs-comment">// Type is string | number</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>If <code>&quot;a&quot; | &quot;b&quot; | &quot;c&quot;</code> is too narrow for <code>k</code>, then <code>string | number</code> is certainly too narrow for <code>v</code>. In the preceding example one of the values is a <code>Date</code>, but it could be anything. The types here give a false sense of certainty that could lead to chaos at runtime.</p><p>So what if you just want to iterate over the object&#39;s keys and values without type errors? <code>Object.entries</code> lets you iterate over both simultaneously:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">abc: ABC</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [k, v] of <span class="hljs-built_in">Object</span>.entries(abc)) &#123;<br>    k  <span class="hljs-comment">// Type is string</span><br>    v  <span class="hljs-comment">// Type is any</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>While these types may be hard to work with, they are at least honest!</p><p>You should also be aware of the possibility of <em>prototype pollution</em>. Even in the case of an object literal that you define, for-in can produce additional keys:</p><pre data-type="programlisting">&gt; <strong>Object.prototype.z = 3;</strong> // Please don't do this!&gt; <strong>const obj = {x: 1, y: 2};</strong>&gt; <strong>for (const k in obj) { console.log(k); }</strong>xyz</pre><p>Hopefully this doesn&#39;t happen in a nonadversarial environment (you should never add enumerable properties to <code>Object.prototype</code>), but it is another reason that for-in produces <code>string</code> keys even for object literals.</p><p>If you want to iterate over the keys and values in an object, use either a <code>keyof</code> declaration (<code>let k: keyof T</code>) or <code>Object.entries</code>. The former is appropriate for constants or other situations where you know that the object won&#39;t have additional keys and you want precise types. The latter is more generally appropriate, though the key and value types are more difficult to work with.</p><h4 id="Things-to-Remember"><a href="#Things-to-Remember" class="headerlink" title="Things to Remember"></a>Things to Remember</h4><ul><li>Use <code>let k: keyof T</code> and a for-in loop to iterate objects when you know exactly what the keys will be. Be aware that any objects your function receives as parameters might have additional keys.</li><li>Use <code>Object.entries</code> to iterate over the keys and values of any object.</li></ul>]]></content>
    
    <summary type="html">
    
      Iterating over the keys and values in an object is a common operation that&#39;s surprisingly hard to write without type assertions in TypeScript. This item explains why the types you get from &lt;code&gt;Object.keys&lt;/code&gt; or a &lt;code&gt;for-in&lt;/code&gt; loop aren&#39;t quite what you&#39;d expect, and what your available workarounds are.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Unionize and Objectify: A Trick for Applying Conditional Types to Objects</title>
    <link href="https://effectivetypescript.com/2020/05/12/unionize-objectify/"/>
    <id>https://effectivetypescript.com/2020/05/12/unionize-objectify/</id>
    <published>2020-05-12T17:00:00.000Z</published>
    <updated>2020-05-12T16:49:27.662Z</updated>
    
    <content type="html"><![CDATA[<p><em>Conditional types are the most powerful weapon TypeScript gives us for mapping between types. They do their best work on union types, so sometimes it pays to apply slightly counterintuitive transformations to get a union of types, rather than an object. This post presents <code>Unionize</code> and <code>Objectify</code>, two tools I&#39;ve found extremely helpful for constructing complex mappings between object types.</em></p><p>Sometimes the easiest way to get from A to B isn&#39;t the direct path. If you have great tools to solve problems in another domain, then mapping your problem onto that domain might just do the trick:</p><p><img src="/images/problem-domain-mapping.png" alt="Going from A to B is hard, but f(A) to f(B) is easy"></p><p>Examples of this are everywhere in math, science and software. It&#39;s not obvious that assigning <a href="https://en.wikipedia.org/wiki/Cartesian_coordinate_system" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://en.wikipedia.org/wiki/Cartesian_coordinate_system'); return false;">cartesian coordinates</a> to points in a geometry problem will help solve it, but it works because we have great tools for solving algebra problems. It&#39;s not obvious that writing computer programs as a series of matrix operations will help you recognize <a href="https://en.wikipedia.org/wiki/MNIST_database" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://en.wikipedia.org/wiki/MNIST_database'); return false;">handwritten digits</a>, but it does because we have great tools like GPUs, <a href="https://en.wikipedia.org/wiki/Backpropagation" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://en.wikipedia.org/wiki/Backpropagation'); return false;">backprop</a> and <a href="https://en.wikipedia.org/wiki/Gradient_descent" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://en.wikipedia.org/wiki/Gradient_descent'); return false;">gradient descent</a> for working with the matrix formulation.</p><p>So what does this have to do with TypeScript? In TypeScript our most powerful tool is <a href="https://artsy.github.io/blog/2018/11/21/conditional-types-in-typescript/" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://artsy.github.io/blog/2018/11/21/conditional-types-in-typescript/'); return false;">conditional types</a>. This is because they have two unique abilities:</p><ol><li>They distribute over unions.</li><li>They enable you to use the <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-inference-in-conditional-types" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-inference-in-conditional-types'); return false;"><code>infer</code> keyword</a>.</li></ol><p>So to the extent that we can map TypeScript problems into the domain of unions and conditional types, we&#39;ll find them easier to solve.</p><h3 id="Jsonify-with-methods"><a href="#Jsonify-with-methods" class="headerlink" title="Jsonify with methods"></a>Jsonify with methods</h3><p>As an example, consider a <a href="https://effectivetypescript.com/2020/04/09/jsonify/">previous post</a> where we looked at the type of a variable before and after JSON serialization:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Student &#123;<br>  id: <span class="hljs-built_in">number</span>;<br>  name: <span class="hljs-built_in">string</span>;<br>  birthday: <span class="hljs-built_in">Date</span> | <span class="hljs-literal">null</span><br>&#125;<br><span class="hljs-keyword">const</span> student: Student = &#123;<br>  id: <span class="hljs-number">123</span>, name: <span class="hljs-string">'Bobby'</span>, birthday: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">'2007-10-10'</span>)<br>&#125;;<br><span class="hljs-keyword">const</span> studentRT = jsonRoundTrip(student);<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//   id: number;</span><br><span class="hljs-comment">//   name: string;</span><br><span class="hljs-comment">//   birthday: string | null;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>The definition of JSON serialization in that post wasn&#39;t quite complete. If there&#39;s a method defined on an object, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify'); return false;">the MDN docs</a> say it will be omitted during serialization:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; JSON.stringify(&#123; name: &#39;Bobby&#39;, age: 12, greet() &#123; return &#39;Hi!&#39;; &#125;&#125;)<br>&#39;&#123;&quot;name&quot;: &quot;Bobby&quot;,&quot;age&quot;: 12&#125;&#39;<br></code></pre></td></tr></table></figure><p>Using the last version of <code>Jsonify</code> from the <a href="https://effectivetypescript.com/2020/04/09/jsonify/">previous post</a>, however, we get something different (<a href="https://www.typescriptlang.org/play/#code/C4TwDgpgBAUgzgewHYEsBmIA8AVAfFAXimyggA9gIkATOKAb2ARgGUB5AOQAoBKALigokaCACcoAVQC+AKChQA-JLlQBJcpRp0EAIwBWEAMbAVS+ivnyA2gGtBSKDYggEaYgF0B8ZOizZb7rgA3BZQsvJqITJoAK5IxijIUHqISABKCHHU2KIoYDi4XGRq-LCpvgUMKqIQwDGiDqycAHRgAIaicBBcTRzNcMC5SADmvkU8PCGyMobIA1AAboTJqRlZOXlc5vJIbQC2EAIA5ABCujogRwA0Km3Dh1AAjABMN-LDNbW8DFA1dQ1QI4ACRQAEIjkEwjcpJMZAB6OFQUCQQR0cwIyxQXYHAQDIbDEIYyx3B5IGJ7HRiQmIywfCC1AT0KTUsIyIA" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://www.typescriptlang.org/play/#code/C4TwDgpgBAUgzgewHYEsBmIA8AVAfFAXimyggA9gIkATOKAb2ARgGUB5AOQAoBKALigokaCACcoAVQC+AKChQA-JLlQBJcpRp0EAIwBWEAMbAVS+ivnyA2gGtBSKDYggEaYgF0B8ZOizZb7rgA3BZQsvJqITJoAK5IxijIUHqISABKCHHU2KIoYDi4XGRq-LCpvgUMKqIQwDGiDqycAHRgAIaicBBcTRzNcMC5SADmvkU8PCGyMobIA1AAboTJqRlZOXlc5vJIbQC2EAIA5ABCujogRwA0Km3Dh1AAjABMN-LDNbW8DFA1dQ1QI4ACRQAEIjkEwjcpJMZAB6OFQUCQQR0cwIyxQXYHAQDIbDEIYyx3B5IGJ7HRiQmIywfCC1AT0KTUsIyIA'); return false;">playground</a>):</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Jsonify&lt;T&gt; = T <span class="hljs-keyword">extends</span> &#123;toJSON(): infer U&#125;<br>  ? U<br>  : T <span class="hljs-keyword">extends</span> object<br>  ? &#123;<br>      [k <span class="hljs-keyword">in</span> keyof T]: Jsonify&lt;T[k]&gt;;<br>    &#125;<br>  : T;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonRoundTrip</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">x: T</span>): <span class="hljs-title">Jsonify</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(x));<br>&#125;<br><br><span class="hljs-keyword">const</span> v = jsonRoundTrip(&#123;<br>  name: <span class="hljs-string">'Bobby'</span>,<br>  age: <span class="hljs-number">12</span>,<br>  greet() &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">'Hi!'</span>; &#125;,<br>&#125;);<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//    name: string;</span><br><span class="hljs-comment">//    age: number;</span><br><span class="hljs-comment">//    greet: &#123;&#125;;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>To get a more accurate type, we&#39;ll need to filter out the properties with function values. But how do you do that? More generally, how do you filter out properties from an object type that are assignable to some other type?</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> OmitProperties&lt;T <span class="hljs-keyword">extends</span> object, V&gt; = ???;<br></code></pre></td></tr></table></figure><h3 id="OmitProperties"><a href="#OmitProperties" class="headerlink" title="OmitProperties"></a>OmitProperties</h3><p>One idea is to use <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types'); return false;">mapped types</a> and conditional types together:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> OmitProperties&lt;T <span class="hljs-keyword">extends</span> object, V&gt; = &#123;<br>  [k <span class="hljs-keyword">in</span> keyof T]: T[k] <span class="hljs-keyword">extends</span> V ? never : T[k];<br>&#125;;<br></code></pre></td></tr></table></figure><p>If the value type for a key (<code>T[k]</code>) extends <code>V</code>, then we change it to a <code>never</code> type. Otherwise we leave it as-is. Here&#39;s how that shakes out:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Person &#123;<br>  name: <span class="hljs-built_in">string</span>;<br>  age: <span class="hljs-built_in">number</span>;<br>  greet: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">type</span> NonFunctionalPeople = OmitProperties&lt;Person, <span class="hljs-built_in">Function</span>&gt;;<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//   name: string;</span><br><span class="hljs-comment">//   age: number;</span><br><span class="hljs-comment">//   greet: never;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>This is close to what we want, but it&#39;s not exactly right. The <code>getId</code> key is still in the result type. It has a <code>never</code> value type, sure, but it&#39;s distracting and it will still show up in <code>keyof</code> expressions:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> K = keyof NonFunctionalPeople;  <span class="hljs-comment">// type is "name" | "age" | "greet"</span><br></code></pre></td></tr></table></figure><p>Depending on the situation, this might be a disaster. For example, if you have a function to index a list based on a field, <code>greet</code> will be allowed because it&#39;s in <code>keyof T</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> people: NonFunctionalPeople[];<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">indexByField</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  vals: T[], field: keyof OmitProperties&lt;T, <span class="hljs-built_in">Function</span>&gt;</span></span><br><span class="hljs-function"><span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br><span class="hljs-keyword">const</span> index = indexByField(people, <span class="hljs-string">'greet'</span>);  <span class="hljs-comment">// OK, should be an error</span><br></code></pre></td></tr></table></figure><p>So what to do? We used conditional types here, but we didn&#39;t apply them to a union type, which is where they do their best work. To make a better  <code>OmitProperties</code>, we need to map from the domain of object types to the domain of union types.</p><h3 id="Unionize-and-Objectify"><a href="#Unionize-and-Objectify" class="headerlink" title="Unionize and Objectify"></a>Unionize and Objectify</h3><p>I learned a trick for this from <a href="https://stackoverflow.com/users/125734/titian-cernicova-dragomir" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://stackoverflow.com/users/125734/titian-cernicova-dragomir'); return false;">Titian Cernicova-Dragomir</a> on <a href="https://stackoverflow.com/a/56416192/388951" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://stackoverflow.com/a/56416192/388951'); return false;">Stack Overflow</a>. You map from an object type to a union type of <code>{k, v}</code> pairs. Let&#39;s call this transformation <code>Unionize</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Unionize&lt;T <span class="hljs-keyword">extends</span> object&gt; = &#123;<br>  [k <span class="hljs-keyword">in</span> keyof T]: &#123;k: k; v: T[k]&#125;<br>&#125;[keyof T];<br><br><span class="hljs-keyword">type</span> PersonUnion = Unionize&lt;Person&gt;;<br><span class="hljs-comment">// type is &#123; k: "name"; v: string; &#125; |</span><br><span class="hljs-comment">//         &#123; k: "age"; v: number; &#125; |</span><br><span class="hljs-comment">//         &#123; k: "greet"; v: () =&gt; string; &#125;</span><br></code></pre></td></tr></table></figure><p>We&#39;ve used a mapped type <code>[k in keyof T]</code> and an index operation <code>[keyof T]</code> to transform the object type into a union of types with <code>k</code> / <code>v</code> pairs. The key is a string literal type and the value is the value type.</p><p>You can put the object back together again using the inverse operation. Let&#39;s call that <code>Objectify</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> KVPair = &#123;k: PropertyKey; v: unknown&#125;<br><span class="hljs-keyword">type</span> Objectify&lt;T <span class="hljs-keyword">extends</span> KVPair&gt; = &#123;<br>  [k <span class="hljs-keyword">in</span> T[<span class="hljs-string">'k'</span>]]: Extract&lt;T, &#123;k: k&#125;&gt;[<span class="hljs-string">'v'</span>]<br>&#125;;<br></code></pre></td></tr></table></figure><p>This one is a little tricker. <code>PropertyKey</code> is an alias for anything that can be used as a property key in TypeScript: <code>string | number | symbol</code>. The <code>T[&#39;k&#39;]</code> extracts all the key types:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> K = PersonUnion[<span class="hljs-string">'k'</span>];  <span class="hljs-comment">// type is "age" | "name" | "greet"</span><br></code></pre></td></tr></table></figure><p>Then we use <a href="https://fettblog.eu/typescript-built-in-generics/#extract" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://fettblog.eu/typescript-built-in-generics/#extract'); return false;"><code>Extract</code></a> to find the k/v pair for each key and pull out the corresponding value:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> KV = Extract&lt;PersonUnion, &#123;k: <span class="hljs-string">'age'</span>&#125;&gt;;  <span class="hljs-comment">// type is &#123;k: "age"; v: number; &#125;</span><br><span class="hljs-keyword">type</span> V = Extract&lt;PersonUnion, &#123;k: <span class="hljs-string">'age'</span>&#125;&gt;[<span class="hljs-string">'v'</span>];  <span class="hljs-comment">// type is number</span><br></code></pre></td></tr></table></figure><p>The result is that we can put our object type back together again:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> ReformedPerson = Objectify&lt;PersonUnion&gt;;<br><span class="hljs-comment">// type ReformedPerson = &#123;</span><br><span class="hljs-comment">//     age: number;</span><br><span class="hljs-comment">//     name: string;</span><br><span class="hljs-comment">//     greet: () =&gt; string;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>So we have a complete mapping between object types and unions of key/value pairs. Now we can put conditional types to work on their home turf! Let&#39;s see what this lets us do.</p><h3 id="OmitProperties-with-the-new-helpers"><a href="#OmitProperties-with-the-new-helpers" class="headerlink" title="OmitProperties with the new helpers"></a>OmitProperties with the new helpers</h3><p>First, <code>OmitProperties</code>. It&#39;s easy to filter a k/v pair based on the value type using a conditional:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> OmitKV&lt;T <span class="hljs-keyword">extends</span> KVPair, V&gt; = T <span class="hljs-keyword">extends</span> &#123;v: V&#125; ? never : T;<br><br><span class="hljs-keyword">type</span> KV1 = OmitKV&lt;&#123;k: <span class="hljs-string">'age'</span>, v: <span class="hljs-built_in">number</span>&#125;, <span class="hljs-built_in">Function</span>&gt;;<br><span class="hljs-comment">// type is &#123; k: "age"; v: number; &#125;</span><br><span class="hljs-keyword">type</span> KV2 = OmitKV&lt;&#123;k: <span class="hljs-string">'greet'</span>, v: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">string</span>&#125;, <span class="hljs-built_in">Function</span>&gt;;<br><span class="hljs-comment">// type is never</span><br></code></pre></td></tr></table></figure><p>Now the fun part! Because <code>OmitKV</code> is a conditional type, it distributes over unions. And in a type union, <code>never</code> disappears:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> KVs = OmitKV&lt;PersonUnion, <span class="hljs-built_in">Function</span>&gt;;<br><span class="hljs-comment">// type KVs = &#123; k: "age"; v: number; &#125; |</span><br><span class="hljs-comment">//            &#123; k: "name"; v: string; &#125;</span><br></code></pre></td></tr></table></figure><p>By sandwiching <code>OmitKV</code> between <code>Unionize</code> and <code>Objectify</code>, we can take the long way around (as in the diagram at the start of the post) and get an <code>OmitProperties</code> implementation:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> OmitProperties&lt;T <span class="hljs-keyword">extends</span> object, V&gt; = Objectify&lt;OmitKV&lt;Unionize&lt;T&gt;, V&gt;&gt;;<br><br><span class="hljs-keyword">type</span> T = OmitProperties&lt;Person, <span class="hljs-built_in">Function</span>&gt;;<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//   name: string;</span><br><span class="hljs-comment">//   age: number;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>The <code>greet</code> property, which was a function, is really, truly gone! 🤩</p><p>You can implement the opposite operation, <code>PickProperties</code>, in a similar way:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> PickKV&lt;T <span class="hljs-keyword">extends</span> KVPair, V&gt; = T <span class="hljs-keyword">extends</span> &#123;v: V&#125; ? T : never;<br><span class="hljs-keyword">type</span> PickProperties&lt;T <span class="hljs-keyword">extends</span> object, V&gt; =<br>  Objectify&lt;PickKV&lt;Unionize&lt;T&gt;, V&gt;&gt;;<br><br><span class="hljs-keyword">type</span> PersonStrings = PickProperties&lt;Person, <span class="hljs-built_in">string</span>&gt;;<br><span class="hljs-comment">// type is &#123; name: string &#125;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">indexByField</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">object</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  obj: T[],</span></span><br><span class="hljs-function"><span class="hljs-params">  field: keyof PickProperties&lt;T, <span class="hljs-built_in">string</span>&gt;</span></span><br><span class="hljs-function"><span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br><br>indexByField(people, <span class="hljs-string">'name'</span>);  <span class="hljs-comment">// OK</span><br>indexByField(people, <span class="hljs-string">'greet'</span>);<br>                   <span class="hljs-comment">// ~~~~~ Argument of type '"greet"' is not assignable</span><br>                   <span class="hljs-comment">//       to parameter of type '"name"'. (2345)</span><br></code></pre></td></tr></table></figure><p>Of course, if you just want the keys then you don&#39;t need to go back through <code>Objectify</code>. Something simpler accomplishes the same thing:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> PickKeys&lt;T <span class="hljs-keyword">extends</span> object, V&gt; =<br>  Extract&lt;Unionize&lt;T&gt;, &#123;v: V&#125;&gt;[<span class="hljs-string">'k'</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">indexByField</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">object</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  obj: T[],</span></span><br><span class="hljs-function"><span class="hljs-params">  field: PickKeys&lt;T, <span class="hljs-built_in">string</span>&gt;</span></span><br><span class="hljs-function"><span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><h3 id="Jsonify-with-Unionize-and-Objectify"><a href="#Jsonify-with-Unionize-and-Objectify" class="headerlink" title="Jsonify with Unionize and Objectify"></a>Jsonify with Unionize and Objectify</h3><p>What other problems can you solve with this technique?</p><p>Looking back at <a href="https://effectivetypescript.com/2020/04/09/jsonify/"><code>Jsonify</code></a>, we can make it filter out Function values:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// (opposite of PickKeys, above)</span><br><span class="hljs-keyword">type</span> OmitKeys&lt;T <span class="hljs-keyword">extends</span> object, V&gt; = Exclude&lt;Unionize&lt;T&gt;, &#123;v: V&#125;&gt;[<span class="hljs-string">'k'</span>];<br><br><span class="hljs-keyword">type</span> Jsonify&lt;T&gt; = T <span class="hljs-keyword">extends</span> &#123;toJSON(): infer U&#125;<br>  ? U<br>  : T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Array</span>&lt;infer U&gt;<br>  ? <span class="hljs-built_in">Array</span>&lt;Jsonify&lt;U&gt;&gt;<br>  : T <span class="hljs-keyword">extends</span> object<br>  ? &#123;<br>      [k <span class="hljs-keyword">in</span> OmitKeys&lt;T, <span class="hljs-built_in">Function</span>&gt;]: Jsonify&lt;T[k]&gt;;<br>    &#125;<br>  : T;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonRoundTrip</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">x: T</span>): <span class="hljs-title">Jsonify</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(x));<br>&#125;<br><br><span class="hljs-keyword">const</span> v = jsonRoundTrip(&#123;<br>  name: <span class="hljs-string">'Bobby'</span>,<br>  age: <span class="hljs-number">12</span>,<br>  greet() &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">'Hi!'</span>; &#125;,<br>&#125;);<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//    name: string;</span><br><span class="hljs-comment">//    age: number;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>The <code>greet</code> method is gone entirely, just as it should be. Amazing!</p><h3 id="Lodash-39-s-invert"><a href="#Lodash-39-s-invert" class="headerlink" title="Lodash&#39;s _.invert"></a>Lodash&#39;s <code>_.invert</code></h3><p>Yet another application (and the one that <a href="https://stackoverflow.com/a/56416192/388951" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://stackoverflow.com/a/56416192/388951'); return false;">introduced me to this technique</a>) is precisely typing <a href="https://lodash.com/docs/4.17.15#invert" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://lodash.com/docs/4.17.15#invert'); return false;">lodash&#39;s <code>_.invert()</code></a>, which swaps the keys and values in an object:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> shortToLong = &#123;<br>  p: <span class="hljs-string">'pageNum'</span>,<br>  n: <span class="hljs-string">'numResults'</span>,<br>&#125;;<br><br><span class="hljs-keyword">const</span> longToShort = _.invert(shortToLong);  <span class="hljs-comment">// what's the type?</span><br></code></pre></td></tr></table></figure><p>As of this writing, the type you get using <code>@types/lodash</code> is just <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/921607887591fbbe2a417b344ad98a1a45cd25d1/types/lodash/common/object.d.ts#L1990-L2002" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://github.com/DefinitelyTyped/DefinitelyTyped/blob/921607887591fbbe2a417b344ad98a1a45cd25d1/types/lodash/common/object.d.ts#L1990-L2002'); return false;"><code>_.Dictionary&lt;string&gt;</code></a>, which isn&#39;t wrong, but also isn&#39;t very precise. You can get a more precise result using <code>keyof</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Inverted&lt;T <span class="hljs-keyword">extends</span> object&gt; = Record&lt;<span class="hljs-built_in">string</span>, keyof T&gt;;<br><span class="hljs-keyword">type</span> T = Inverted&lt;<span class="hljs-keyword">typeof</span> shortToLong&gt;;<br><span class="hljs-comment">// type T = &#123;</span><br><span class="hljs-comment">//    [x: string]: "p" | "n";</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>The <code>shortToLong</code> constant is probably intended to be entirely immutable, so we can use a <a href="https://blog.logrocket.com/const-assertions-are-the-killer-new-typescript-feature-b73451f35802/" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://blog.logrocket.com/const-assertions-are-the-killer-new-typescript-feature-b73451f35802/'); return false;">const assertion</a> to get a more precise type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> shortToLong = &#123;<br>  p: <span class="hljs-string">'pageNum'</span>,<br>  n: <span class="hljs-string">'numResults'</span>,<br>&#125; <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;<br><span class="hljs-comment">// type is &#123; readonly p: 'pageNum'; readonly n: 'numResults'; &#125;</span><br></code></pre></td></tr></table></figure><p>Now we should be able to get a <em>really</em> precise type for the inverse! It should be <code>{pageNum: &#39;p&#39;; numResults: &#39;n&#39;;}</code>. Let&#39;s see how <code>Unionize</code> and <code>Objectify</code> can help us get there.</p><p>First of all, swapping the <code>k</code> and <code>v</code> in a k/v pair is easy:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> SwapKV&lt;T&gt; =<br>  T <span class="hljs-keyword">extends</span> &#123;k: infer K, v: infer V&#125;<br>  ? &#123;k: V; v: K; &#125;  <span class="hljs-comment">// &lt;-- note the swap!</span><br>  : never;<br></code></pre></td></tr></table></figure><p>Here we&#39;ve used the <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-inference-in-conditional-types" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-inference-in-conditional-types'); return false;"><code>infer</code> keyword</a> (a conditional types superpower) to pull out the key and value types from a k/v pair.</p><p>If you try to wrap this in <code>Unionize</code> and <code>Objectify</code>, you&#39;ll get a very long, cryptic error. I&#39;ll spare you the full message, but the root cause is that <code>Objectify</code> requires that <code>k</code> be a <code>PropertyKey</code> and there&#39;s no guarantee that <code>V</code> is assignable to that. If we bake in that constraint, then everything works:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> SwapKV&lt;T&gt; =<br>  T <span class="hljs-keyword">extends</span> &#123;k: infer K, v: infer V&#125;<br>  ? V <span class="hljs-keyword">extends</span> PropertyKey  <span class="hljs-comment">// &lt;-- additional PropertyKey constraint</span><br>  ? &#123;k: V; v: K; &#125;  <span class="hljs-comment">// &lt;-- note the swap!</span><br>  : never<br>  : never;<br><span class="hljs-keyword">type</span> Inverted&lt;T <span class="hljs-keyword">extends</span> object&gt; = Objectify&lt;SwapKV&lt;Unionize&lt;T&gt;&gt;&gt;;<br></code></pre></td></tr></table></figure><p>Now we get perfect types:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T = Inverted&lt;<span class="hljs-keyword">typeof</span> shortToLong&gt;;<br><span class="hljs-comment">// type T = &#123;</span><br><span class="hljs-comment">//     pageNum: "p";</span><br><span class="hljs-comment">//     numResults: "n";</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>If you drop the <code>as const</code>, you&#39;ll get a less-precise type, just like before. It would be nice to restrict <code>Inverted</code> to only allow types with <code>PropertyKey</code> values, but I&#39;ll leave that as an exercise to the reader.</p><p>If you have duplicate values, you get a union of the values for the key type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> playerToTeam = &#123;<br>  a: <span class="hljs-string">'A'</span>,<br>  b: <span class="hljs-string">'A'</span>,<br>  c: <span class="hljs-string">'B'</span>,<br>&#125; <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;<br><br><span class="hljs-keyword">type</span> T = Inverted&lt;<span class="hljs-keyword">typeof</span> playerToTeam&gt;;<br><span class="hljs-comment">// type T = &#123;</span><br><span class="hljs-comment">//     A: "a" | "b";</span><br><span class="hljs-comment">//     B: "c";</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>This seems sensible since TypeScript doesn&#39;t have a notion of the order of keys in an object or elements in a union. I recommend working out the sequence of operations yourself to see how this union (<code>&quot;a&quot; | &quot;b&quot;</code>) comes about.</p><!--It would be nice if TypeScript displayed types as objects in this:function invert<T extends object>(o: T): Inverted<T> {  return _.invert(o);}const invMapping = invert(mapping);// const invMapping: Objectify<{//     k: "fooBar";//     v: "foo_bar";// } | {//     k: "bazQuux";//     v: "baz_quux";// } | {//     k: "fooBar";//     v: "bar";// }>Titian's `{} &` trick seems to be of no use here.--><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Ever since I learned about them, I&#39;ve been finding more and more uses for <code>Unionize</code> and <code>Objectify</code>. You&#39;ve seen three of them in this post, but I&#39;m sure there are many others. They have a real knack for transforming difficult problems with object types into much simpler problems with union types. Next time you run into a problem with types, think about whether unionization can help!</p><p>To experiment with the code samples in this post, use <a href="https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyyIcAthAFzIZhSgDmA3EcnA1SQK5kBG0LYgygQIYagAoAlMgC8APhp1GLAL4ECYAJ4AHFAFUQwHMABeEADwAVZBAAekEABMMyLLwBWEBGEWz8rADaANbIoMjBEFpYMMhWALrUeMHUwUzIAG7UViHx6qohUTFx8SyauijoUNgghsa4-nUm5hZVNfIsAPSdyNp6Ya54EdQARKQUI+lZSvQgzMiqyAA+BN3E6xtDKcgj7BCTmdQgPPxQ6YsraxubwzvComAH09JyirSz8+rl-QDSAGqoODAKByfDbVBQLB6KDaH5RKbULggYIgLAAdxA6j6KAA8p5vGBgDAtNZbA4IM5XP9AcC-AFiCEwrgcgByYIs+KJZAAUQcUEQYGsABowalVPJAiyMhyCKoytjkAAlCAwLBQChONo4UF4rw+IkkrW1Iw4DqrHoK5Wq9UQTWYbX+QhXdZ7I4nATm67jTjvFSejb3MSSGQKGZ+tZfBU4sjAMD-Un2RwuZDUoFQEV-Ok2RMU5N4aZ-RYAfhIEAy0GQ2XlFRTfwAjDqY3G-hZktQWXsWSLpsc+NBVCKAGJI-WmroWmvAQa3XYcJ5uvtnBbfFD-ABMjdj8bbyBZgbAXcOyBeod9cwHyGHIFHIDNawVU9L5agGgV-1c-mjW5bRqaICHI6EmOnpvn8H74DOezztwi7nMs-rXNcWyjN60Fnp8r41l+YAQlC0CEhAGAJuSlJuPiPgZnSuoEgaFjYfGf5mJYVjyJRZornEm44ZC0IEURRoAdeQG3uOvSToMCHetQ6GicQrowacomRjWqDAAgwTxtmJHJqmwKUaCWlJoMBbFpxRxlh6CqqepuG8cAhHEUZZF6mA+myKw1H6sSrRqRpLaMS0LFsdW-RGgAysoczgdZwS2fh9n8fa-5hnMd4Tv0j5DFJKUMMuHExXCWhEYZuauO4LluawvJ0AKFgBcxrH4CZEpshyZQwIB9RMk49gAEJaIO9kADZOI5pXOQS8gSKw5XZIE8RCqwMDDU41AFVExUiuh8gEDIQydAAVMgAB0p3IAdPRfD1CBDXAIjIENYjIHoUKPWtSXzSwoA9XY-WDRAI0SC9OiPSKLLeiyUjpMgaw4j8BDfX1A0rUDECvRAYP7pDgiIbjGxrAAfkTRPIAAglADA8BSYBuLECosiM+4jCyAwkFgNNwBgGDAAwpC8I9rB43jzobGAWDPXd5BiBWxT02MUvM8dx5rgAzAALAArFIGhrBIUI6Fg3OQLTaC+YVGAinAvBYOW2tRk25tjaR5UEm5PJ2DdXA9XVJpGIFjX5tQhYteypSYf0ABSNS0SxBlkk5eBixHYU4gActI1CgDAFb6OoxAlvorDZPH43k-yJJZznO352TUDlxYUcmN5+jyNXlacTmzvkWArAloQiGMuE9EbcKl6daaXKN0Y3k5ME8Rmhseft1Y7Xj7gHg1IqWBIk4Vj0Do1hTXY2RSNQU8x4o-fICIYBcFAuDJ2nx06HdGAQBIj+p8d6EGhIdhSFDWUGgEA4FoJkUEG8cBbx3nvYAOgJBX2yiyXq7heBaC7KweSdY1yLSECIMQLwhg3zvrgFkAAJYAABCFk5xFqqEAfecSAQRbZRkghNgHAFyKU9F8EBIAwEYAABZqjAFYLAAAZHAuVHSsB0O2F+HBU48AwcQEA7ZezKgwFwIaYAMAYMWJzZAfDaAhRQGFNEcAdCaT8KwEqpEdyVxBD8bsmcQDZxBIWXuyA-gl1InFGEWhCrEDWBYAAtKEtgTgnCxnqHAIaaAeL4UCVEIxoCaqgB7jXHcfwEQpjgjDHoYSImomNmAQRKAMAWJ0JQouT5oC1JABZM4HEACSIBnyQFGnY5MLsfBUW7rRcxliGK+yYofVupi4gtNBG0jptoLDYmKEIkRYjJGpVEgqKw0yZEiwloongowdCTHYTBTR2jdEoWORGYBaTnq3S0NAMRVgIDkFBFfOA7ZSYqOQLwT53yEDtl6votgrhjFgEmVYVAMz2n4XmYs2IIM4APKgE8l5ZA0piX6JCt5JzSajDgCMZYOxeBXJ6BsXqowECkuXEAA" target="_blank" rel="noopener" onclick="trackOutboundLink('conclusion', 'https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyyIcAthAFzIZhSgDmA3EcnA1SQK5kBG0LYgygQIYagAoAlMgC8APhp1GLAL4ECYAJ4AHFAFUQwHMABeEADwAVZBAAekEABMMyLLwBWEBGEWz8rADaANbIoMjBEFpYMMhWALrUeMHUwUzIAG7UViHx6qohUTFx8SyauijoUNgghsa4-nUm5hZVNfIsAPSdyNp6Ya54EdQARKQUI+lZSvQgzMiqyAA+BN3E6xtDKcgj7BCTmdQgPPxQ6YsraxubwzvComAH09JyirSz8+rl-QDSAGqoODAKByfDbVBQLB6KDaH5RKbULggYIgLAAdxA6j6KAA8p5vGBgDAtNZbA4IM5XP9AcC-AFiCEwrgcgByYIs+KJZAAUQcUEQYGsABowalVPJAiyMhyCKoytjkAAlCAwLBQChONo4UF4rw+IkkrW1Iw4DqrHoK5Wq9UQTWYbX+QhXdZ7I4nATm67jTjvFSejb3MSSGQKGZ+tZfBU4sjAMD-Un2RwuZDUoFQEV-Ok2RMU5N4aZ-RYAfhIEAy0GQ2XlFRTfwAjDqY3G-hZktQWXsWSLpsc+NBVCKAGJI-WmroWmvAQa3XYcJ5uvtnBbfFD-ABMjdj8bbyBZgbAXcOyBeod9cwHyGHIFHIDNawVU9L5agGgV-1c-mjW5bRqaICHI6EmOnpvn8H74DOezztwi7nMs-rXNcWyjN60Fnp8r41l+YAQlC0CEhAGAJuSlJuPiPgZnSuoEgaFjYfGf5mJYVjyJRZornEm44ZC0IEURRoAdeQG3uOvSToMCHetQ6GicQrowacomRjWqDAAgwTxtmJHJqmwKUaCWlJoMBbFpxRxlh6CqqepuG8cAhHEUZZF6mA+myKw1H6sSrRqRpLaMS0LFsdW-RGgAysoczgdZwS2fh9n8fa-5hnMd4Tv0j5DFJKUMMuHExXCWhEYZuauO4LluawvJ0AKFgBcxrH4CZEpshyZQwIB9RMk49gAEJaIO9kADZOI5pXOQS8gSKw5XZIE8RCqwMDDU41AFVExUiuh8gEDIQydAAVMgAB0p3IAdPRfD1CBDXAIjIENYjIHoUKPWtSXzSwoA9XY-WDRAI0SC9OiPSKLLeiyUjpMgaw4j8BDfX1A0rUDECvRAYP7pDgiIbjGxrAAfkTRPIAAglADA8BSYBuLECosiM+4jCyAwkFgNNwBgGDAAwpC8I9rB43jzobGAWDPXd5BiBWxT02MUvM8dx5rgAzAALAArFIGhrBIUI6Fg3OQLTaC+YVGAinAvBYOW2tRk25tjaR5UEm5PJ2DdXA9XVJpGIFjX5tQhYteypSYf0ABSNS0SxBlkk5eBixHYU4gActI1CgDAFb6OoxAlvorDZPH43k-yJJZznO352TUDlxYUcmN5+jyNXlacTmzvkWArAloQiGMuE9EbcKl6daaXKN0Y3k5ME8Rmhseft1Y7Xj7gHg1IqWBIk4Vj0Do1hTXY2RSNQU8x4o-fICIYBcFAuDJ2nx06HdGAQBIj+p8d6EGhIdhSFDWUGgEA4FoJkUEG8cBbx3nvYAOgJBX2yiyXq7heBaC7KweSdY1yLSECIMQLwhg3zvrgFkAAJYAABCFk5xFqqEAfecSAQRbZRkghNgHAFyKU9F8EBIAwEYAABZqjAFYLAAAZHAuVHSsB0O2F+HBU48AwcQEA7ZezKgwFwIaYAMAYMWJzZAfDaAhRQGFNEcAdCaT8KwEqpEdyVxBD8bsmcQDZxBIWXuyA-gl1InFGEWhCrEDWBYAAtKEtgTgnCxnqHAIaaAeL4UCVEIxoCaqgB7jXHcfwEQpjgjDHoYSImomNmAQRKAMAWJ0JQouT5oC1JABZM4HEACSIBnyQFGnY5MLsfBUW7rRcxliGK+yYofVupi4gtNBG0jptoLDYmKEIkRYjJGpVEgqKw0yZEiwloongowdCTHYTBTR2jdEoWORGYBaTnq3S0NAMRVgIDkFBFfOA7ZSYqOQLwT53yEDtl6votgrhjFgEmVYVAMz2n4XmYs2IIM4APKgE8l5ZA0piX6JCt5JzSajDgCMZYOxeBXJ6BsXqowECkuXEAA'); return false;">this playground link</a>.</p><p><em>A huge thanks to <a href="https://stackoverflow.com/users/125734/titian-cernicova-dragomir" target="_blank" rel="noopener" onclick="trackOutboundLink('conclusion', 'https://stackoverflow.com/users/125734/titian-cernicova-dragomir'); return false;">Titian</a> for introducing me to this! He uses &quot;AllValues&quot; instead of &quot;Unionize&quot;. If you don&#39;t like the names, feel free to choose your own. You could go with &quot;ToPairs&quot; and &quot;FromPairs&quot; to match lodash, or &quot;ToUnion&quot; and &quot;ToObject&quot;. If you just want something like <code>OmitProperties</code>, take a look at ts-essential&#39;s <a href="https://github.com/krzkaczor/ts-essentials#omitproperties" target="_blank" rel="noopener" onclick="trackOutboundLink('conclusion', 'https://github.com/krzkaczor/ts-essentials#omitproperties'); return false;"><code>OmitProperties</code></a>.</em></p>]]></content>
    
    <summary type="html">
    
      Conditional types are the most powerful weapon TypeScript gives us for mapping between types. They do their best work on union types, so sometimes it pays to apply slightly counterintuitive transformations to get a union of types, rather than an object. This post presents &lt;code&gt;Unionize&lt;/code&gt; and &lt;code&gt;Objectify&lt;/code&gt;, two tools I&#39;ve found extremely helpful for constructing complex mappings between object types.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Item 19: Avoid Cluttering Your Code with Inferable Types</title>
    <link href="https://effectivetypescript.com/2020/04/28/avoid-inferable/"/>
    <id>https://effectivetypescript.com/2020/04/28/avoid-inferable/</id>
    <published>2020-04-28T15:23:45.000Z</published>
    <updated>2020-04-28T01:23:35.078Z</updated>
    
    <content type="html"><![CDATA[<p><em>Chapter 3 of <a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://amzn.to/38s1oCK'); return false;">Effective TypeScript</a> covers type inference: the process by which TypeScript infers the type of symbols in the absence of explicit annotations. A significant fraction of the comments I leave on TypeScript code reviews point out places where type annotations are unnecessary and can be omitted. This item explains why explicitly annotating inferable types is typically a bad idea, and enumerates a few specific exceptions to this rule.</em></p><p>The first thing that many new TypeScript developers do when they convert a codebase from JavaScript is fill it with type annotations. TypeScript is about <em>types</em>, after all! But in TypeScript many annotations are unnecessary. Declaring types for all your variables is counterproductive and is considered poor style.</p><p>Don’t write:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> x: <span class="hljs-built_in">number</span> = <span class="hljs-number">12</span>;<br></code></pre></td></tr></table></figure><p>Instead, just write:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> x = <span class="hljs-number">12</span>;<br></code></pre></td></tr></table></figure><p>If you mouse over <code>x</code> in your editor, you’ll see that its type has been inferred as <code>number</code>:</p><img src="/images/efts_03in01.png" title="A text editor showing that the inferred type of x is number." width="33%"><p>The explicit type annotation is redundant. Writing it just adds noise. If you&#39;re unsure of the type, you can check it in your editor.</p><p>TypeScript will also infer the types of more complex objects. Instead of:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> person: &#123;<br>  name: <span class="hljs-built_in">string</span>;<br>  born: &#123;<br>    where: <span class="hljs-built_in">string</span>;<br>    when: <span class="hljs-built_in">string</span>;<br>  &#125;;<br>  died: &#123;<br>    where: <span class="hljs-built_in">string</span>;<br>    when: <span class="hljs-built_in">string</span>;<br>  &#125;<br>&#125; = &#123;<br>  name: <span class="hljs-string">'Sojourner Truth'</span>,<br>  born: &#123;<br>    where: <span class="hljs-string">'Swartekill, NY'</span>,<br>    when: <span class="hljs-string">'c.1797'</span>,<br>  &#125;,<br>  died: &#123;<br>    where: <span class="hljs-string">'Battle Creek, MI'</span>,<br>    when: <span class="hljs-string">'Nov. 26, 1883'</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>you can just write:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> person = &#123;<br>  name: <span class="hljs-string">'Sojourner Truth'</span>,<br>  born: &#123;<br>    where: <span class="hljs-string">'Swartekill, NY'</span>,<br>    when: <span class="hljs-string">'c.1797'</span>,<br>  &#125;,<br>  died: &#123;<br>    where: <span class="hljs-string">'Battle Creek, MI'</span>,<br>    when: <span class="hljs-string">'Nov. 26, 1883'</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Again, the types are exactly the same. Writing the type in addition to the value just adds noise here. (Item 21, Understand Type Widening, has more to say on the types inferred for object literals.)</p><p>What&#39;s true for objects is also true for arrays. TypeScript has no trouble figuring out the return type of this function based on its inputs and operations:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[]</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> nums.map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * x);<br>&#125;<br><span class="hljs-keyword">const</span> squares = square([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]); <span class="hljs-comment">// Type is number[]</span><br></code></pre></td></tr></table></figure><p>TypeScript may infer something more precise than what you expected. This is generally a good thing. For example:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> axis1: <span class="hljs-built_in">string</span> = <span class="hljs-string">'x'</span>;  <span class="hljs-comment">// Type is string</span><br><span class="hljs-keyword">const</span> axis2 = <span class="hljs-string">'y'</span>;  <span class="hljs-comment">// Type is "y"</span><br></code></pre></td></tr></table></figure><p><code>&quot;y&quot;</code> is a more precise type for the <code>axis</code> variable, and using it may fix some errors that would appear with the less-precise <code>string</code>.</p><p>Allowing types to be inferred can also facilitate refactoring. Say you have a <code>Product</code> type and a function to log it:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Product &#123;<br>  id: <span class="hljs-built_in">number</span>;<br>  name: <span class="hljs-built_in">string</span>;<br>  price: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logProduct</span>(<span class="hljs-params">product: Product</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> id: <span class="hljs-built_in">number</span> = product.id;<br>  <span class="hljs-keyword">const</span> name: <span class="hljs-built_in">string</span> = product.name;<br>  <span class="hljs-keyword">const</span> price: <span class="hljs-built_in">number</span> = product.price;<br>  <span class="hljs-built_in">console</span>.log(id, name, price);<br>&#125;<br></code></pre></td></tr></table></figure><p>At some point you learn that product IDs might have letters in them in addition to numbers. So you change the type of <code>id</code> in <code>Product</code>. Because you included explicit annotations on all the variables in <code>logProduct</code>, this produces an error:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Product &#123;<br>  id: <span class="hljs-built_in">string</span>;<br>  name: <span class="hljs-built_in">string</span>;<br>  price: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logProduct</span>(<span class="hljs-params">product: Product</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> id: <span class="hljs-built_in">number</span> = product.id;<br>     <span class="hljs-comment">// ~~ Type 'string' is not assignable to type 'number'</span><br>  <span class="hljs-keyword">const</span> name: <span class="hljs-built_in">string</span> = product.name;<br>  <span class="hljs-keyword">const</span> price: <span class="hljs-built_in">number</span> = product.price;<br>  <span class="hljs-built_in">console</span>.log(id, name, price);<br>&#125;<br></code></pre></td></tr></table></figure><p>Had you left off all the annotations in the <code>logProduct</code> function body, the code would have passed the type checker without modification.</p><p>A better implementation of <code>logProduct</code> would use destructuring assignment:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logProduct</span>(<span class="hljs-params">product: Product</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123;id, name, price&#125; = product;<br>  <span class="hljs-built_in">console</span>.log(id, name, price);<br>&#125;<br></code></pre></td></tr></table></figure><p>This version allows the types of all the local variables to be inferred. The corresponding version with explicit type annotations is repetitive and cluttered:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logProduct</span>(<span class="hljs-params">product: Product</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123;id, name, price&#125;: &#123;id: <span class="hljs-built_in">string</span>; name: <span class="hljs-built_in">string</span>; price: <span class="hljs-built_in">number</span> &#125; = product;<br>  <span class="hljs-built_in">console</span>.log(id, name, price);<br>&#125;<br></code></pre></td></tr></table></figure><p>Explicit type annotations are still required in some situations where TypeScript doesn’t have enough context to determine a type on its own. You have seen one of these before: function parameters.</p><p>Some languages will infer types for parameters based on their eventual usage, but TypeScript does not. In TypeScript, a variable&#39;s type is generally determined when it is first introduced.</p><p>Ideal TypeScript code includes type annotations for function/method signatures but not for the local variables created in their bodies. This keeps noise to a minimum and lets readers focus on the implementation logic.</p><p>There are some situations where you can leave the type annotations off of function parameters, too. When there’s a default value, for example:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseNumber</span>(<span class="hljs-params">str: <span class="hljs-built_in">string</span>, base=10</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Here the type of <code>base</code> is inferred as <code>number</code> because of the default value of <code>10</code>.</p><p>Parameter types can usually be inferred when the function is used as a callback for a library with type declarations. The declarations on <code>request</code> and <code>response</code> in this example using the express HTTP server library are not required:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Don't do this:</span><br>app.get(<span class="hljs-string">'/health'</span>, <span class="hljs-function">(<span class="hljs-params">request: express.Request, response: express.Response</span>) =&gt;</span> &#123;<br>  response.send(<span class="hljs-string">'OK'</span>);<br>&#125;);<br><br><span class="hljs-comment">// Do this:</span><br>app.get(<span class="hljs-string">'/health'</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>  response.send(<span class="hljs-string">'OK'</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>For much more on this, see Item 26: Understand How Context Is Used in Type Inference.</p><p>There are a few situations where you may still want to specify a type even where it can be inferred.</p><p>One is when you define an object literal:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> elmo: Product = &#123;<br>  name: <span class="hljs-string">'Tickle Me Elmo'</span>,<br>  id: <span class="hljs-string">'048188 627152'</span>,<br>  price: <span class="hljs-number">28.99</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>When you specify a type on a definition like this, you enable excess property checking. This can help catch errors, particularly for types with optional fields. (This is discussed in more detail in Item 11: Recognize the Limits of Excess Property Checking.)</p><p>You also increase the odds that an error will be reported in the right place. If you leave off the annotation, a mistake in the object&#39;s definition will result in a type error where it&#39;s used, rather than where it&#39;s defined:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> furby = &#123;<br>  name: <span class="hljs-string">'Furby'</span>,<br>  id: <span class="hljs-number">630509430963</span>,<br>  price: <span class="hljs-number">35</span>,<br>&#125;;<br>logProduct(furby);<br>        <span class="hljs-comment">// ~~~~~ Argument .. is not assignable to parameter of type 'Product'</span><br>        <span class="hljs-comment">//         Types of property 'id' are incompatible</span><br>        <span class="hljs-comment">//         Type 'number' is not assignable to type 'string'</span><br></code></pre></td></tr></table></figure><p>With an annotation, you get a more concise error in the place where the mistake was made:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"> <span class="hljs-keyword">const</span> furby: Product = &#123;<br>   name: <span class="hljs-string">'Furby'</span>,<br>   id: <span class="hljs-number">630509430963</span>,<br><span class="hljs-comment">// ~~ Type 'number' is not assignable to type 'string'</span><br>   price: <span class="hljs-number">35</span>,<br> &#125;;<br> logProduct(furby);<br></code></pre></td></tr></table></figure><p>Similar considerations apply to a function&#39;s return type. You may still want to annotate this even when it can be inferred to ensure that implementation errors don&#39;t leak out into uses of the function.</p><p>Say you have a function which retrieves a stock quote:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getQuote</span>(<span class="hljs-params">ticker: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">`https://quotes.example.com/?q=<span class="hljs-subst">$&#123;ticker&#125;</span>`</span>)<br>      .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json());<br>&#125;<br></code></pre></td></tr></table></figure><p>You decide to add a cache to avoid duplicating network requests:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> cache: &#123;[ticker: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>&#125; = &#123;&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getQuote</span>(<span class="hljs-params">ticker: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (ticker <span class="hljs-keyword">in</span> cache) &#123;<br>    <span class="hljs-keyword">return</span> cache[ticker];<br>  &#125;<br>  <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">`https://quotes.example.com/?q=<span class="hljs-subst">$&#123;ticker&#125;</span>`</span>)<br>      .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())<br>      .then(<span class="hljs-function"><span class="hljs-params">quote</span> =&gt;</span> &#123;<br>        cache[ticker] = quote;<br>        <span class="hljs-keyword">return</span> quote;<br>      &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>There’s a mistake in this implementation: you should really be returning <code>Promise.resolve(cache[ticker])</code> so that <code>getQuote</code> always returns a Promise. The mistake will most likely produce an error… but in the code that calls <code>getQuote</code>, rather than in <code>getQuote</code> itself:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">getQuote(<span class="hljs-string">'MSFT'</span>).then(considerBuying);<br>              <span class="hljs-comment">// ~~~~ Property 'then' does not exist on type</span><br>              <span class="hljs-comment">//        'number | Promise&lt;any&gt;'</span><br>              <span class="hljs-comment">//      Property 'then' does not exist on type 'number'</span><br></code></pre></td></tr></table></figure><p>Had you annotated the intended return type (<code>Promise&lt;number&gt;</code>), the error would have been reported in the correct place:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> cache: &#123;[ticker: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>&#125; = &#123;&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getQuote</span>(<span class="hljs-params">ticker: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">number</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">if</span> (ticker <span class="hljs-keyword">in</span> cache) &#123;<br>    <span class="hljs-keyword">return</span> cache[ticker];<br>        <span class="hljs-comment">// ~~~~~~~~~~~~~ Type 'number' is not assignable to 'Promise&lt;number&gt;'</span><br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>When you annotate the return type, it keeps implementation errors from manifesting as errors in user code. (<code>async</code> functions are an effective way to avoid this specific error with Promises. They&#39;re discused in detail in Item 25: Use async Functions Instead of Callbacks for Asynchronous Code).</p><p>Writing out the return type may also help you think more clearly about your function: you should know what its input and output types are <em>before you implement it</em>. While the implementation may shift around a bit, the function&#39;s contract (its type signature) generally should not. This is similar in spirit to test-driven development (TDD), in which you write the tests that exercise a function before you implement it. Writing the full type signature first helps get you the function you want, rather than the one the implementation makes expedient.</p><p>A final reason to annotate return values is if you want to use a named type. You might choose not to write a return type for this function, for example:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Vector2D &#123; x: <span class="hljs-built_in">number</span>; y: <span class="hljs-built_in">number</span>; &#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a: Vector2D, b: Vector2D</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123; x: a.x + b.x, y: a.y + b.y &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>TypeScript infers the return type as <code>{ x: number; y: number; }</code>. This is compatible with <code>Vector2D</code>, but it may be surprising to users of your code when they see <code>Vector2D</code> as a type of the input and not of the output:</p><img src="/images/efts_03in02.png" title="The parameters to the add function have named types, while the inferred return value does not." width="75%"><p>If you annotate the return type, the presentation is more straightforward. And if you&#39;ve written documentation on the type (Item 48: Use TSDoc for API Comments) then it will be associated with the returned value as well. As the complexity of the inferred return type increases, it becomes increasingly helpful to provide a name.</p><p>If you are using a linter, the eslint rule <code>no-inferrable-types</code> (note the variant spelling) can help ensure that all your type annotations are really necessary.</p><h3 id="Things-to-Remember"><a href="#Things-to-Remember" class="headerlink" title="Things to Remember"></a>Things to Remember</h3><ul><li>Avoid writing type annotations when TypeScript can infer the same type.</li><li>Ideally your code has type annotations in function/method signatures but not on local variables in their bodies.</li><li>Consider using explicit annotations for object literals and function return types even when they can be inferred. This will help prevent implementation errors from surfacing in user code.</li></ul>]]></content>
    
    <summary type="html">
    
      The first thing that many new TypeScript developers do when they convert a codebase from JavaScript is fill it with type annotations. TypeScript is about &lt;i&gt;types&lt;/i&gt;, after all! But in TypeScript many annotations are unnecessary. Declaring types for all your variables is counterproductive and is considered poor style.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>What&#39;s the type of JSON.parse(​JSON.stringify(x))?</title>
    <link href="https://effectivetypescript.com/2020/04/09/jsonify/"/>
    <id>https://effectivetypescript.com/2020/04/09/jsonify/</id>
    <published>2020-04-09T15:00:56.000Z</published>
    <updated>2020-04-20T00:17:41.653Z</updated>
    
    <content type="html"><![CDATA[<p>If you&#39;re writing a server in JavaScript, you might write an endpoint that converts an object to JSON:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">app.get(<span class="hljs-string">'/user'</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> user = getCurrentUser();<br>  response.json(user);<br>&#125;);<br></code></pre></td></tr></table></figure><p>On the client, you might use the <code>fetch</code> API to hit this endpoint and deserialize (parse) the data:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'/user'</span>);<br><span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> response.json();<br></code></pre></td></tr></table></figure><p>What&#39;s the relationship between the <code>user</code> object in the server and the corresponding <code>user</code> object in the client? And how would you model this in TypeScript?</p><a id="more"></a><p>Because the serialization and deserialization <a href="https://github.com/expressjs/express/blob/67e64ca4c1c5b26cf971e6d6c35278d6357dc6bb/lib/response.js#L1122" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://github.com/expressjs/express/blob/67e64ca4c1c5b26cf971e6d6c35278d6357dc6bb/lib/response.js#L1122'); return false;">ultimately happens</a> via JavaScript&#39;s built-in <code>JSON.stringify</code> and <code>JSON.parse</code> functions, we can alternatively ask: what&#39;s the return type of this function?</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonRoundTrip</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">x: T</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(x));<br>&#125;<br></code></pre></td></tr></table></figure><p>If you mouse over <code>jsonRoundTrip</code> on the <a href="https://www.typescriptlang.org/play/?ssl=1&ssc=1&pln=10&pc=1#code/GYVwdgxgLglg9mABAKwM4IEp3AEwCoBOMADgDx4B8AFAB4BcieAlIgN4BQiiBAplCASQApAMoB5AHIA6YgEMCqHlVGSpqKETABzGMACetJkwDc7AL7sgA" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://www.typescriptlang.org/play/?ssl=1&ssc=1&pln=10&pc=1#code/GYVwdgxgLglg9mABAKwM4IEp3AEwCoBOMADgDx4B8AFAB4BcieAlIgN4BQiiBAplCASQApAMoB5AHIA6YgEMCqHlVGSpqKETABzGMACetJkwDc7AL7sgA'); return false;">TypeScript playground</a>, you&#39;ll see that its inferred return type is <code>any</code>. That&#39;s not very satisfying!</p><p>It&#39;s tempting to make the return type <code>T</code>, so that this is like an identity function:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonRoundTrip</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">x: T</span>): <span class="hljs-title">T</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(x));<br>&#125;<br></code></pre></td></tr></table></figure><p>But this isn&#39;t quite right. First of all, there are many objects which can&#39;t be directly represented in JSON. A regular expression, for instance:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; JSON.stringify(&#x2F;foo&#x2F;)<br>&#39;&#123;&#125;&#39;<br></code></pre></td></tr></table></figure><p>Second, there are some values that get transformed in the conversion process. For example, <code>undefined</code> in an array becomes <code>null</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; arr &#x3D; [undefined]<br>&gt; jsonRoundTrip(arr)<br>[ null ]<br></code></pre></td></tr></table></figure><p>With <code>strictNullChecks</code> in TypeScript, <code>null</code> and <code>undefined</code> have distinct types.</p><p>If an object has a <code>toJSON</code> method, it will get called by <code>JSON.stringify</code>. This is implemented by some of the standard types in JavaScript, notably <code>Date</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; d &#x3D; new Date();<br>&gt; jsonRoundTrip(d)<br>&#39;2020-04-09T01:07:48.835Z&#39;<br></code></pre></td></tr></table></figure><p>So <code>Date</code>s get converted to <code>string</code>s. Who knew? You can read the full details of how this works <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify'); return false;">on MDN</a>.</p><p>How to model this in TypeScript? Let&#39;s just focus on the behavior around Dates. For a complex mapping like this, we&#39;re going to want a <a href="https://artsy.github.io/blog/2018/11/21/conditional-types-in-typescript/" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://artsy.github.io/blog/2018/11/21/conditional-types-in-typescript/'); return false;">conditional type</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Jsonify&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Date</span> ? <span class="hljs-built_in">string</span> : T;<br></code></pre></td></tr></table></figure><p>This is already doing something sensible:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T1 = Jsonify&lt;<span class="hljs-built_in">string</span>&gt;; <span class="hljs-comment">// Type is string</span><br><span class="hljs-keyword">type</span> T2 = Jsonify&lt;<span class="hljs-built_in">Date</span>&gt;; <span class="hljs-comment">// Type is string</span><br><span class="hljs-keyword">type</span> T3 = Jsonify&lt;<span class="hljs-built_in">boolean</span>&gt;; <span class="hljs-comment">// Type is boolean</span><br></code></pre></td></tr></table></figure><p>We even get support for union types because conditional types distribute over unions:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T = Jsonify&lt;<span class="hljs-built_in">Date</span> | <span class="hljs-literal">null</span>&gt;;  <span class="hljs-comment">// Type is string | null</span><br></code></pre></td></tr></table></figure><p>But what about object types? Usually the <code>Date</code>s are buried somehwere in a larger type. So we&#39;ll need to make <code>Jsonify</code> recursive. This is possible <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#more-recursive-type-aliases" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#more-recursive-type-aliases'); return false;">as of TypeScript 3.7</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Jsonify&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Date</span><br>  ? <span class="hljs-built_in">string</span><br>  : T <span class="hljs-keyword">extends</span> object<br>  ? &#123;<br>      [k <span class="hljs-keyword">in</span> keyof T]: Jsonify&lt;T[k]&gt;;<br>    &#125;<br>  : T;<br></code></pre></td></tr></table></figure><p>In the case that we have an object type, we use a <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types'); return false;">mapped type</a> to recursively apply the <code>Jsonify</code> transformation. This is already starting to make some interesting new types!</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Student &#123;<br>  id: <span class="hljs-built_in">number</span>;<br>  name: <span class="hljs-built_in">string</span>;<br>  birthday: <span class="hljs-built_in">Date</span> | <span class="hljs-literal">null</span><br>&#125;<br><span class="hljs-keyword">type</span> T1 = Jsonify&lt;Student&gt;;<br><span class="hljs-comment">// type T1 = &#123;</span><br><span class="hljs-comment">//   id: number;</span><br><span class="hljs-comment">//   name: string;</span><br><span class="hljs-comment">//   birthday: string | null;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-keyword">interface</span> Class &#123;<br>  valedictorian: Student;<br>  salutatorian?: Student;<br>&#125;<br><span class="hljs-keyword">type</span> T2 = Jsonify&lt;Class&gt;;<br><span class="hljs-comment">// type T2 = &#123;</span><br><span class="hljs-comment">//   valedictorian: &#123;</span><br><span class="hljs-comment">//     id: number;</span><br><span class="hljs-comment">//     name: string;</span><br><span class="hljs-comment">//     birthday: string | null;</span><br><span class="hljs-comment">//   &#125;;</span><br><span class="hljs-comment">//   salutatorian?: &#123;</span><br><span class="hljs-comment">//     id: number;</span><br><span class="hljs-comment">//     name: string;</span><br><span class="hljs-comment">//     birthday: string | null;</span><br><span class="hljs-comment">//   &#125; | undefined;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>What if there&#39;s an array involved? Does that work?</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Class &#123;<br>    teacher: <span class="hljs-built_in">string</span>;<br>    start: <span class="hljs-built_in">Date</span>;<br>    stop: <span class="hljs-built_in">Date</span>;<br>    students: Student[];<br>&#125;<br><span class="hljs-keyword">type</span> T = Jsonify&lt;Class&gt;;<br><span class="hljs-comment">// type T = &#123;</span><br><span class="hljs-comment">//   teacher: string;</span><br><span class="hljs-comment">//   start: string;</span><br><span class="hljs-comment">//   stop: string;</span><br><span class="hljs-comment">//   students: &#123;</span><br><span class="hljs-comment">//     id: number;</span><br><span class="hljs-comment">//     name: string;</span><br><span class="hljs-comment">//     birthday: string | null;</span><br><span class="hljs-comment">//   &#125;[];</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>It does! How was TypeScript able to figure that out?</p><p>First of all, Arrays are objects, so <code>T extends object</code> is true for any array type. And <code>keyof T[]</code> includes <code>number</code>, since you can index into an array with a <code>number</code>. But it also includes methods like <code>length</code> and <code>toString</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T = keyof Student[];  <span class="hljs-comment">// type is number | "length" | "toString" | ...</span><br></code></pre></td></tr></table></figure><p>So it&#39;s a bit of a surprise <code>Jsonify</code> produces such a clean type for the array. Perhaps mapped types over arrays are special cased.</p><p>But regardless, this is great! We can even loosen the definition slightly to handle any object with a <code>toJSON()</code> method (including Dates):</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Jsonify&lt;T&gt; = T <span class="hljs-keyword">extends</span> &#123;toJSON(): infer U&#125;<br>  ? U<br>  : T <span class="hljs-keyword">extends</span> object<br>  ? &#123;<br>      [k <span class="hljs-keyword">in</span> keyof T]: Jsonify&lt;T[k]&gt;;<br>    &#125;<br>  : T;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonRoundTrip</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">x: T</span>): <span class="hljs-title">Jsonify</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(x));<br>&#125;<br><br><span class="hljs-keyword">const</span> student: Student = &#123;<br>  id: <span class="hljs-number">327</span>, name: <span class="hljs-string">'Bobby'</span>, birthday: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">'2007-10-10'</span>)<br>&#125;;<br><span class="hljs-keyword">const</span> studentRT = jsonRoundTrip(student);<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//   id: number;</span><br><span class="hljs-comment">//   name: string;</span><br><span class="hljs-comment">//   birthday: string | null;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-keyword">const</span> objWithToJSON = &#123;<br>  x: <span class="hljs-number">5</span>, y: <span class="hljs-number">6</span>, toJSON()&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.x + <span class="hljs-keyword">this</span>.y; &#125;<br>&#125;;<br><span class="hljs-keyword">const</span> objRT = jsonRoundTrip(objWithToJSON);<br><span class="hljs-comment">// type is number!</span><br></code></pre></td></tr></table></figure><p>Here we&#39;ve used the <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-inference-in-conditional-types" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-inference-in-conditional-types'); return false;">infer keyword</a> to infer the return type of the <code>toJSON</code> method of the object. Try the last example out in <a href="https://www.typescriptlang.org/play/?ssl=25&ssc=11&pln=25&pc=62#code/C4TwDgpgBAUgzgewHYEsBmIA8AVAfFAXimyggA9gIkATOKAb2ARgGUB5AOQAoBKALigokaCACcoAVQC+AKChQA-JLlQBJcpRp0EAIwBWEAMbAVS+ivnyA2gGtBSKDYggEaYgF0B8ZOizZb7rgA3BZQsvJqITJoAK5IxijIUHqISABKCHHU2KIoYDi4XGRq-LCpvgUMKqIQwDGiDqycAHRgAIaicBBcTRzNcMC5SADmvkU8PCGyQpSiaG2G0Cx11FTAVfIo1AJIMQC2OmIh8khtexACA0PDx1A6KKLAABbUbSACACJtlFAAPlC7AA2gJkskMyAGUAGMVWSGAAmWMLWhAYWwEAEYAEwAZgANACzhcoAByABCuh0IGJ+Pujxebx2EAA7lAvpQuMTMQAGLkAdgAtOiuYKucSeFIQuCkJDobDgGkSEQUsgMlkcnkuLK1pMZAB6XVQUCQQR0cz6yxogH7Q6iELmk6Ey6DIQ3PUG+S056vd5Q50jP5W4F2g2yGRSyEIFH0KDFKAAVnxPoAbPimL1eNGanUGoanig4M0yFAANS5-PNEBBMJhSUQ9YIBUo5XpTI0dVgLgIHXmo3QfNWg5iACEMiAA" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://www.typescriptlang.org/play/?ssl=25&ssc=11&pln=25&pc=62#code/C4TwDgpgBAUgzgewHYEsBmIA8AVAfFAXimyggA9gIkATOKAb2ARgGUB5AOQAoBKALigokaCACcoAVQC+AKChQA-JLlQBJcpRp0EAIwBWEAMbAVS+ivnyA2gGtBSKDYggEaYgF0B8ZOizZb7rgA3BZQsvJqITJoAK5IxijIUHqISABKCHHU2KIoYDi4XGRq-LCpvgUMKqIQwDGiDqycAHRgAIaicBBcTRzNcMC5SADmvkU8PCGyQpSiaG2G0Cx11FTAVfIo1AJIMQC2OmIh8khtexACA0PDx1A6KKLAABbUbSACACJtlFAAPlC7AA2gJkskMyAGUAGMVWSGAAmWMLWhAYWwEAEYAEwAZgANACzhcoAByABCuh0IGJ+Pujxebx2EAA7lAvpQuMTMQAGLkAdgAtOiuYKucSeFIQuCkJDobDgGkSEQUsgMlkcnkuLK1pMZAB6XVQUCQQR0cz6yxogH7Q6iELmk6Ey6DIQ3PUG+S056vd5Q50jP5W4F2g2yGRSyEIFH0KDFKAAVnxPoAbPimL1eNGanUGoanig4M0yFAANS5-PNEBBMJhSUQ9YIBUo5XpTI0dVgLgIHXmo3QfNWg5iACEMiAA'); return false;">the playground</a>. It really does return a <code>number</code>!</p><p>As TypeScript Development lead Ryan Cavanaugh once <a href="https://twitter.com/SeaRyanC/status/1029846761718702081" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://twitter.com/SeaRyanC/status/1029846761718702081'); return false;">said</a>, it&#39;s remarkable how many problems are solved by conditional types. The types involved in JSON serialization are one of them! If you produce and consume JSON in a TypeScript project, consider using something like <code>Jsonify</code> to safely handle Dates in your objects.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;If you&amp;#39;re writing a server in JavaScript, you might write an endpoint that converts an object to JSON:&lt;/p&gt;
&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs ts&quot;&gt;app.get(&lt;span class=&quot;hljs-string&quot;&gt;&#39;/user&#39;&lt;/span&gt;, &lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;request, response&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;br&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; user = getCurrentUser();&lt;br&gt;  response.json(user);&lt;br&gt;&amp;#125;);&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;On the client, you might use the &lt;code&gt;fetch&lt;/code&gt; API to hit this endpoint and deserialize (parse) the data:&lt;/p&gt;
&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs ts&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; response = &lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; fetch(&lt;span class=&quot;hljs-string&quot;&gt;&#39;/user&#39;&lt;/span&gt;);&lt;br&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; user = &lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; response.json();&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;What&amp;#39;s the relationship between the &lt;code&gt;user&lt;/code&gt; object in the server and the corresponding &lt;code&gt;user&lt;/code&gt; object in the client? And how would you model this in TypeScript?&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Item 31: Push Null Values to the Perimeter of Your Types</title>
    <link href="https://effectivetypescript.com/2020/03/24/null-values-to-perimeter/"/>
    <id>https://effectivetypescript.com/2020/03/24/null-values-to-perimeter/</id>
    <published>2020-03-24T14:05:00.000Z</published>
    <updated>2020-03-24T14:03:45.188Z</updated>
    
    <content type="html"><![CDATA[<p><em>Chapter 4 of <a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://amzn.to/38s1oCK'); return false;">Effective TypeScript</a> covers type design: the process of crafting your types to accurately model your domain. Design your types well and you&#39;ll have a happy, productive relationship with the type checker. Design them poorly and you&#39;ll find yourself constantly fighting unproductive battles with it. This item discusses a frequent source of problems in type design: where to put your <code>null</code> types.</em></p><p>When you first turn on <code>strictNullChecks</code>, it may seem as though you have to add scores of <code>if</code> statements checking for <code>null</code> and <code>undefined</code> values throughout your code. This is often because the relationships between null and non-null values are implicit: when variable A is non-null, you know that variable B is also non-null and vice versa. These implicit relationships are confusing both for human readers of your code and for the type checker.</p><p>Values are easier to work with when they&#39;re either completely null or completely non-null, rather than a mix. You can model this by pushing the null values out to the perimeter of your structures.</p><p>Suppose you want to calculate the min and max of a list of numbers. We&#39;ll call this the &quot;extent.&quot; Here&#39;s an attempt:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extent</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[]</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> min, max;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num of nums) &#123;<br>    <span class="hljs-keyword">if</span> (!min) &#123;<br>      min = num;<br>      max = num;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      min = <span class="hljs-built_in">Math</span>.min(min, num);<br>      max = <span class="hljs-built_in">Math</span>.max(max, num);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> [min, max];<br>&#125;<br></code></pre></td></tr></table></figure><p>The code type checks (without <code>strictNullChecks</code>) and has an inferred return type of <code>number[]</code>, which seems fine. But it has a bug and a design flaw:</p><ul><li>If the min or max is zero, it may get overridden. For example, <code>extent([0, 1, 2])</code> will return <code>[1, 2]</code> rather than <code>[0, 2]</code>.</li><li>If the <code>nums</code> array is empty, the function will return <code>[undefined, undefined]</code>. This sort of object with several <code>undefined</code>s will be difficult for clients to work with and is exactly the sort of type that this item discourages. We know from reading the source code that <code>min</code> and <code>max</code> will either both be <code>undefined</code> or neither, but that information isn&#39;t represented in the type system.</li></ul><p>Turning on <code>strictNullChecks</code> makes both of these issues more apparent:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extent</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[]</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> min, max;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num of nums) &#123;<br>    <span class="hljs-keyword">if</span> (!min) &#123;<br>      min = num;<br>      max = num;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      min = <span class="hljs-built_in">Math</span>.min(min, num);<br>      max = <span class="hljs-built_in">Math</span>.max(max, num);<br>                  <span class="hljs-comment">// ~~~ Argument of type 'number | undefined' is not</span><br>                  <span class="hljs-comment">//     assignable to parameter of type 'number'</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> [min, max];<br>&#125;<br></code></pre></td></tr></table></figure><p>The return type of <code>extent</code> is now inferred as <code>(number | undefined)[]</code>, which makes the design flaw more apparent. This is likely to manifest as a type error wherever you call <code>extent</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> [min, max] = extent([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]);<br><span class="hljs-keyword">const</span> span = max - min;<br>          <span class="hljs-comment">// ~~~   ~~~ Object is possibly 'undefined'</span><br></code></pre></td></tr></table></figure><p>The error in the implementation of <code>extent</code> comes about because you&#39;ve excluded <code>undefined</code> as a value for <code>min</code> but not <code>max</code>. The two are initialized together, but this information isn&#39;t present in the type system. You could make it go away by adding a check for <code>max</code>, too, but this would be doubling down on the bug.</p><p>A better solution is to put the min and max in the same object and make this object either fully <code>null</code> or fully non-<code>null</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extent</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[]</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> result: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>] | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num of nums) &#123;<br>    <span class="hljs-keyword">if</span> (!result) &#123;<br>      result = [num, num];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      result = [<span class="hljs-built_in">Math</span>.min(num, result[<span class="hljs-number">0</span>]), <span class="hljs-built_in">Math</span>.max(num, result[<span class="hljs-number">1</span>])];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>The return type is now <code>[number, number] | null</code>, which is easier for clients to work with. The min and max can be retrieved with either a non-null assertion:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> [min, max] = extent([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>])!;<br><span class="hljs-keyword">const</span> span = max - min;  <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><p>or a single check:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> range = extent([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]);<br><span class="hljs-keyword">if</span> (range) &#123;<br>  <span class="hljs-keyword">const</span> [min, max] = range;<br>  <span class="hljs-keyword">const</span> span = max - min;  <span class="hljs-comment">// OK</span><br>&#125;<br></code></pre></td></tr></table></figure><p>By using a single object to track the extent, we&#39;ve improved our design, helped TypeScript understand the relationship between null values, and fixed the bug: the <code>if (!result)</code> check is now problem free.</p><p>A mix of null and non-null values can also lead to problems in classes. For instance, suppose you have a class that represents both a user and their posts on a forum:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> UserPosts &#123;<br>  user: UserInfo | <span class="hljs-literal">null</span>;<br>  posts: Post[] | <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">this</span>.user = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">this</span>.posts = <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">async</span> init(userId: <span class="hljs-built_in">string</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all([<br>      <span class="hljs-keyword">async</span> () =&gt; <span class="hljs-keyword">this</span>.user = <span class="hljs-keyword">await</span> fetchUser(userId),<br>      <span class="hljs-keyword">async</span> () =&gt; <span class="hljs-keyword">this</span>.posts = <span class="hljs-keyword">await</span> fetchPostsForUser(userId)<br>    ]);<br>  &#125;<br><br>  getUserName() &#123;<br>    <span class="hljs-comment">// ...?</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>While the two network requests are loading, the <code>user</code> and <code>posts</code> properties will be <code>null</code>. At any time, they might both be <code>null</code>, one might be <code>null</code>, or they might both be non-<code>null</code>. There are four possibilities. This complexity will seep into every method on the class. This design is almost certain to lead to confusion, a proliferation of <code>null</code> checks, and bugs.</p><p>A better design would wait until all the data used by the class is available:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> UserPosts &#123;<br>  user: UserInfo;<br>  posts: Post[];<br><br>  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">user: UserInfo, posts: Post[]</span>) &#123;<br>    <span class="hljs-keyword">this</span>.user = user;<br>    <span class="hljs-keyword">this</span>.posts = posts;<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> init(userId: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">Promise</span>&lt;UserPosts&gt; &#123;<br>    <span class="hljs-keyword">const</span> [user, posts] = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([<br>      fetchUser(userId),<br>      fetchPostsForUser(userId)<br>    ]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserPosts(user, posts);<br>  &#125;<br><br>  getUserName() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.user.name;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Now the <code>UserPosts</code> class is fully non-<code>null</code>, and it&#39;s easy to write correct methods on it. Of course, if you need to perform operations while data is partially loaded, then you&#39;ll need to deal with the multiplicity of <code>null</code> and non-<code>null</code> states.</p><p>(Don&#39;t be tempted to replace nullable properties with Promises. This tends to lead to even more confusing code and forces all your methods to be async. Promises clarify the code that loads data but tend to have the opposite effect on the class that uses that data.)</p><h3 id="Things-to-Remember"><a href="#Things-to-Remember" class="headerlink" title="Things to Remember"></a>Things to Remember</h3><ul><li>Avoid designs in which one value being <code>null</code> or not <code>null</code> is implicitly related to another value being <code>null</code> or not <code>null</code>.</li><li>Push <code>null</code> values to the perimeter of your API by making larger objects either <code>null</code> or fully non-<code>null</code>. This will make code clearer both for human readers and for the type checker.</li><li>Consider creating a fully non-<code>null</code> class and constructing it when all values are available.</li><li>While <code>strictNullChecks</code> may flag many issues in your code, it&#39;s indispensable for surfacing the behavior of functions with respect to null values.</li></ul>]]></content>
    
    <summary type="html">
    
      When you first turn on &lt;code&gt;strictNullChecks&lt;/code&gt;, it may seem as though you have to add scores of &lt;code&gt;if&lt;/code&gt; statements checking for &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; values throughout your code. This is often because the relationships between null and non-null values are implicit: when variable A is non-null, you know that variable B is also non-null and vice versa. These implicit relationships are confusing both for human readers of your code and for the type checker.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Item 41: Understand Evolving any</title>
    <link href="https://effectivetypescript.com/2020/03/09/evolving-any/"/>
    <id>https://effectivetypescript.com/2020/03/09/evolving-any/</id>
    <published>2020-03-09T16:34:56.000Z</published>
    <updated>2020-03-09T16:32:44.839Z</updated>
    
    <content type="html"><![CDATA[<p><em>This feature was introduced way back in <a href="https://github.com/Microsoft/TypeScript/wiki/What' target=" _blank" rel="noopener" s-new-in-typescript#improved-any-inference" target="_blank" onclick="trackOutboundLink('', 'https://github.com/Microsoft/TypeScript/wiki/What' target='); return false;">TypeScript 2.1</a> in 2016. The term &quot;evolving any&quot; is not widely used outside the TypeScript compiler itself, but I find it useful to have a name for this unusual pattern.</em></p><p>In TypeScript a variable&#39;s type is generally determined when it is declared. After this, it can be <em>refined</em> (by checking if it is <code>null</code>, for instance), but it cannot expand to include new values. There is one notable exception to this, however, involving <code>any</code> types.</p><p>In JavaScript, you might write a function to generate a range of numbers like this:</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">range</span>(<span class="hljs-params">start, limit</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> out = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; limit; i++) &#123;<br>    out.push(i);<br>  &#125;<br>  <span class="hljs-keyword">return</span> out;<br>&#125;<br></code></pre></td></tr></table></figure><p>When you convert this to TypeScript, it works exactly as you&#39;d expect:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">range</span>(<span class="hljs-params">start: <span class="hljs-built_in">number</span>, limit: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> out = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; limit; i++) &#123;<br>    out.push(i);<br>  &#125;<br>  <span class="hljs-keyword">return</span> out;  <span class="hljs-comment">// Return type inferred as number[]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Upon closer inspection, however, it&#39;s surprising that this works! How does TypeScript know that the type of <code>out</code> is <code>number[]</code> when it&#39;s initialized as <code>[]</code>, which could be an array of any type?</p><p>Inspecting each of the three occurrences of <code>out</code> to reveal its inferred type starts to tell the story:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">range</span>(<span class="hljs-params">start: <span class="hljs-built_in">number</span>, limit: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> out = [];  <span class="hljs-comment">// Type is any[]</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; limit; i++) &#123;<br>    out.push(i);  <span class="hljs-comment">// Type of out is any[]</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> out;  <span class="hljs-comment">// Type is number[]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>The type of <code>out</code> starts as <code>any[]</code>, an undifferentiated array. But as we push <code>number</code> values onto it, its type &quot;evolves&quot; to become <code>number[]</code>.</p><p>This is distinct from narrowing (Item 22). An array&#39;s type can expand by pushing different elements onto it:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> result = [];  <span class="hljs-comment">// Type is any[]</span><br>result.push(<span class="hljs-string">'a'</span>);<br>result  <span class="hljs-comment">// Type is string[]</span><br>result.push(<span class="hljs-number">1</span>);<br>result  <span class="hljs-comment">// Type is (string | number)[]</span><br></code></pre></td></tr></table></figure><p>With conditionals, the type can even vary across branches. Here we show the same behavior with a simple value, rather than an array:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> val;  <span class="hljs-comment">// Type is any</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.random() &lt; <span class="hljs-number">0.5</span>) &#123;<br>  val = <span class="hljs-regexp">/hello/</span>;<br>  val  <span class="hljs-comment">// Type is RegExp</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  val = <span class="hljs-number">12</span>;<br>  val  <span class="hljs-comment">// Type is number</span><br>&#125;<br>val  <span class="hljs-comment">// Type is number | RegExp</span><br></code></pre></td></tr></table></figure><p>A final case that triggers this &quot;evolving any&quot; behavior is if a variable is initially <code>null</code>. This often comes up when you set a value in a <code>try</code>/<code>catch</code> block:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> val = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// Type is any</span><br><span class="hljs-keyword">try</span> &#123;<br>  somethingDangerous();<br>  val = <span class="hljs-number">12</span>;<br>  val  <span class="hljs-comment">// Type is number</span><br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">'alas!'</span>);<br>&#125;<br>val  <span class="hljs-comment">// Type is number | null</span><br></code></pre></td></tr></table></figure><p>Interestingly, this behavior only happens when a variable&#39;s type is implicitly <code>any</code> with <code>noImplicitAny</code> set! Adding an <em>explicit</em> <code>any</code> keeps the type constant:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> val: <span class="hljs-built_in">any</span>;  <span class="hljs-comment">// Type is any</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.random() &lt; <span class="hljs-number">0.5</span>) &#123;<br>  val = <span class="hljs-regexp">/hello/</span>;<br>  val  <span class="hljs-comment">// Type is any</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  val = <span class="hljs-number">12</span>;<br>  val  <span class="hljs-comment">// Type is any</span><br>&#125;<br>val  <span class="hljs-comment">// Type is any</span><br></code></pre></td></tr></table></figure><hr><!-- TODO: insert note icon --><p>This behavior can be confusing to follow in your editor since the type is only &quot;evolved&quot; <em>after</em> you assign or push an element. Inspecting the type on the line with the assignment will still show <code>any</code> or <code>any[]</code>.</p><hr><p>If you use a value before any assignment to it, you&#39;ll get an implicit any error:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">range</span>(<span class="hljs-params">start: <span class="hljs-built_in">number</span>, limit: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> out = [];<br>  <span class="hljs-comment">//    ~~~ Variable 'out' implicitly has type 'any[]' in some</span><br>  <span class="hljs-comment">//        locations where its type cannot be determined</span><br>  <span class="hljs-keyword">if</span> (start === limit) &#123;<br>    <span class="hljs-keyword">return</span> out;<br>    <span class="hljs-comment">//     ~~~ Variable 'out' implicitly has an 'any[]' type</span><br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; limit; i++) &#123;<br>    out.push(i);<br>  &#125;<br>  <span class="hljs-keyword">return</span> out;<br>&#125;<br></code></pre></td></tr></table></figure><p>Put another way, &quot;evolving&quot; <code>any</code> types are only <code>any</code> when you <em>write</em> to them. If you try to <em>read</em> from them while they&#39;re still <code>any</code>, you&#39;ll get an error.</p><p>Implicit <code>any</code> types do not evolve through function calls. The arrow function here trips up inference:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeSquares</span>(<span class="hljs-params">start: <span class="hljs-built_in">number</span>, limit: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> out = [];<br>     <span class="hljs-comment">// ~~~ Variable 'out' implicitly has type 'any[]' in some locations</span><br>  range(start, limit).forEach(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> &#123;<br>    out.push(i * i);<br>  &#125;);<br>  <span class="hljs-keyword">return</span> out;<br>      <span class="hljs-comment">// ~~~ Variable 'out' implicitly has an 'any[]' type</span><br>&#125;<br></code></pre></td></tr></table></figure><p>In cases like this, you may want to consider using an array&#39;s <code>map</code> and <code>filter</code> methods to build arrays in a single statement and avoid iteration and evolving <code>any</code> entirely. See Items 23 and 27.</p><p>Evolving <code>any</code> comes with all the usual caveats about type inference. Is the correct type for your array really <code>(string|number)[]</code>? Or should it be <code>number[]</code> and you incorrectly pushed a <code>string</code>? You may still want to provide an explicit type annotation to get better error checking instead of using evolving <code>any</code>.</p><h3 id="Things-to-Remember"><a href="#Things-to-Remember" class="headerlink" title="Things to Remember"></a>Things to Remember</h3><ul><li>While TypeScript types typically only <em>refine</em>, implicit <code>any</code> and <code>any[]</code> types are allowed to <em>evolve</em>. You should be able to recognize and understand this construct where it occurs.</li><li>For better error checking, consider providing an explicit type annotation instead of using evolving <code>any</code>.</li></ul>]]></content>
    
    <summary type="html">
    
      In TypeScript a variable&#39;s type is generally determined when it is declared. After this, it can be &lt;em&gt;refined&lt;/em&gt; (by checking if it is &lt;code&gt;null&lt;/code&gt;, for instance), but it cannot expand to include new values. There is one notable exception to this, however, involving &lt;code&gt;any&lt;/code&gt; types.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Welcome to Effective TypeScript!</title>
    <link href="https://effectivetypescript.com/2020/03/06/hello-world/"/>
    <id>https://effectivetypescript.com/2020/03/06/hello-world/</id>
    <published>2020-03-06T17:34:56.000Z</published>
    <updated>2020-03-12T15:40:49.361Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to the Effective TypeScript website! <a id="more"></a></p><p><a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://amzn.to/38s1oCK'); return false;"><em>Effective TypeScript</em></a> (the book) waspublished at the end of October 2019.</p><p>This companion site was a bit long in coming, but I hope to use it to:</p><ul><li>Post sample items</li><li>Post updates when TypeScript releases change the advice in the book.</li><li>Share links to conference presentations and videos.</li><li>Show examples of how to apply the items in the book.</li><li>Show general TypeScript tips &amp; tricks.</li></ul><p>An inspiration for this last one is the <a href="https://www.centauri-dreams.org/" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://www.centauri-dreams.org/'); return false;">Centauri Dreams</a> blog, which started as acompanion site for a book published in 2004 but is still going strong 16 years later.</p><p>Look for posts every ~2 weeks.</p><p>I built this site using <a href="https://hexo.io/" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://hexo.io/'); return false;">hexo</a>, a popular JavaScript-based static site generator. If you visit the <a href="https://effectivepython.com/" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://effectivepython.com/'); return false;"><em>Effective Python</em> site</a>, you&#39;ll notice a strong family resemblance. So a big thanks to <a href="https://twitter.com/haxor" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://twitter.com/haxor'); return false;">Brett</a> for that!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to the Effective TypeScript website!
    
    </summary>
    
    
    
  </entry>
  
</feed>
