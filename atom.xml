<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Effective TypeScript</title>
  <icon>https://effectivetypescript.com/icon.png</icon>
  <subtitle>62 Specific Ways to Improve Your TypeScript</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://effectivetypescript.com/"/>
  <updated>2020-04-09T14:57:56.880Z</updated>
  <id>https://effectivetypescript.com/</id>
  
  <author>
    <name>Dan Vanderkam</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>What&#39;s the type of JSON.parse(JSON.stringify(x))?</title>
    <link href="https://effectivetypescript.com/2020/04/09/jsonify/"/>
    <id>https://effectivetypescript.com/2020/04/09/jsonify/</id>
    <published>2020-04-09T15:00:56.000Z</published>
    <updated>2020-04-09T14:57:56.880Z</updated>
    
    <content type="html"><![CDATA[<p>If you&#39;re writing a server in JavaScript, you might write an endpoint that converts an object to JSON:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">app.get(<span class="hljs-string">'/user'</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> user = getCurrentUser();<br>  response.json(user);<br>&#125;);<br></code></pre></td></tr></table></figure><p>On the client, you might use the <code>fetch</code> API to hit this endpoint and deserialize (parse) the data:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'/user'</span>);<br><span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> response.json();<br></code></pre></td></tr></table></figure><p>What&#39;s the relationship between the <code>user</code> object in the server and the corresponding <code>user</code> object in the client? And how would you model this in TypeScript?</p><a id="more"></a><p>Because the serialization and deserialization <a href="https://github.com/expressjs/express/blob/67e64ca4c1c5b26cf971e6d6c35278d6357dc6bb/lib/response.js#L1122" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://github.com/expressjs/express/blob/67e64ca4c1c5b26cf971e6d6c35278d6357dc6bb/lib/response.js#L1122'); return false;">ultimately happens</a> via JavaScript&#39;s built-in <code>JSON.stringify</code> and <code>JSON.parse</code> functions, we can alternatively ask: what&#39;s the return type of this function?</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonRoundTrip</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">x: T</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(x));<br>&#125;<br></code></pre></td></tr></table></figure><p>If you mouse over <code>jsonRoundTrip</code> on the <a href="https://www.typescriptlang.org/play/?ssl=1&ssc=1&pln=10&pc=1#code/GYVwdgxgLglg9mABAKwM4IEp3AEwCoBOMADgDx4B8AFAB4BcieAlIgN4BQiiBAplCASQApAMoB5AHIA6YgEMCqHlVGSpqKETABzGMACetJkwDc7AL7sgA" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://www.typescriptlang.org/play/?ssl=1&ssc=1&pln=10&pc=1#code/GYVwdgxgLglg9mABAKwM4IEp3AEwCoBOMADgDx4B8AFAB4BcieAlIgN4BQiiBAplCASQApAMoB5AHIA6YgEMCqHlVGSpqKETABzGMACetJkwDc7AL7sgA'); return false;">TypeScript playground</a>, you&#39;ll see that its inferred return type is <code>any</code>. That&#39;s not very satisfying!</p><p>It&#39;s tempting to make the return type <code>T</code>, so that this is like an identity function:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonRoundTrip</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">x: T</span>): <span class="hljs-title">T</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(x));<br>&#125;<br></code></pre></td></tr></table></figure><p>But this isn&#39;t quite right. First of all, there are many objects which can&#39;t be directly represented in JSON. A regular expression, for instance:</p><pre><code>&gt; JSON.stringify(/foo/)&apos;{}&apos;</code></pre><p>Second, there are some values that get transformed in the conversion process. For example, <code>undefined</code> in an array becomes <code>null</code>:</p><pre><code>&gt; arr = [undefined]&gt; jsonRoundTrip(arr)[ null ]</code></pre><p>With <code>strictNullChecks</code> in TypeScript, <code>null</code> and <code>undefined</code> have distinct types.</p><p>If an object has a <code>toJSON</code> method, it will get called by <code>JSON.stringify</code>. This is implemented by some of the standard types in JavaScript, notably <code>Date</code>:</p><pre><code>&gt; d = new Date();&gt; jsonRoundTrip(d)&apos;2020-04-09T01:07:48.835Z&apos;</code></pre><p>So <code>Date</code>s get converted to <code>string</code>s. Who knew? You can read the full details of how this works <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify'); return false;">on MDN</a>.</p><p>How to model this in TypeScript? Let&#39;s just focus on the behavior around Dates. For a complex mapping like this, we&#39;re going to want a <a href="https://artsy.github.io/blog/2018/11/21/conditional-types-in-typescript/" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://artsy.github.io/blog/2018/11/21/conditional-types-in-typescript/'); return false;">conditional type</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Jsonify&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Date</span> ? <span class="hljs-built_in">string</span> : T;<br></code></pre></td></tr></table></figure><p>This is already doing something sensible:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T1 = Jsonify&lt;<span class="hljs-built_in">string</span>&gt;; <span class="hljs-comment">// Type is string</span><br><span class="hljs-keyword">type</span> T2 = Jsonify&lt;<span class="hljs-built_in">Date</span>&gt;; <span class="hljs-comment">// Type is string</span><br><span class="hljs-keyword">type</span> T3 = Jsonify&lt;<span class="hljs-built_in">boolean</span>&gt;; <span class="hljs-comment">// Type is boolean</span><br></code></pre></td></tr></table></figure><p>We even get support for union types because conditional types distribute over unions:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T = Jsonify&lt;<span class="hljs-built_in">Date</span> | <span class="hljs-literal">null</span>&gt;;  <span class="hljs-comment">// Type is string | null</span><br></code></pre></td></tr></table></figure><p>But what about object types? Usually the <code>Date</code>s are buried somehwere in a larger type. So we&#39;ll need to make <code>Jsonify</code> recursive. This is possible <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#more-recursive-type-aliases" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#more-recursive-type-aliases'); return false;">as of TypeScript 3.7</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Jsonify&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Date</span><br>  ? <span class="hljs-built_in">string</span><br>  : T <span class="hljs-keyword">extends</span> object<br>  ? &#123;<br>      [k <span class="hljs-keyword">in</span> keyof T]: Jsonify&lt;T[k]&gt;;<br>    &#125;<br>  : T;<br></code></pre></td></tr></table></figure><p>In the case that we have an object type, we use a <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types'); return false;">mapped type</a> to recursively apply the <code>Jsonify</code> transformation. This is already starting to make some interesting new types!</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Student &#123;<br>  id: <span class="hljs-built_in">number</span>;<br>  name: <span class="hljs-built_in">string</span>;<br>  birthday: <span class="hljs-built_in">Date</span> | <span class="hljs-literal">null</span><br>&#125;<br><span class="hljs-keyword">type</span> T1 = Jsonify&lt;Student&gt;;<br><span class="hljs-comment">// type T1 = &#123;</span><br><span class="hljs-comment">//   id: number;</span><br><span class="hljs-comment">//   name: string;</span><br><span class="hljs-comment">//   birthday: string | null;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-keyword">interface</span> Class &#123;<br>  valedictorian: Student;<br>  salutatorian?: Student;<br>&#125;<br><span class="hljs-keyword">type</span> T2 = Jsonify&lt;Class&gt;;<br><span class="hljs-comment">// type T2 = &#123;</span><br><span class="hljs-comment">//   valedictorian: &#123;</span><br><span class="hljs-comment">//     id: number;</span><br><span class="hljs-comment">//     name: string;</span><br><span class="hljs-comment">//     birthday: string | null;</span><br><span class="hljs-comment">//   &#125;;</span><br><span class="hljs-comment">//   salutatorian?: &#123;</span><br><span class="hljs-comment">//     id: number;</span><br><span class="hljs-comment">//     name: string;</span><br><span class="hljs-comment">//     birthday: string | null;</span><br><span class="hljs-comment">//   &#125; | undefined;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>What if there&#39;s an array involved? Does that work?</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Class &#123;<br>    teacher: <span class="hljs-built_in">string</span>;<br>    start: <span class="hljs-built_in">Date</span>;<br>    stop: <span class="hljs-built_in">Date</span>;<br>    students: Student[];<br>&#125;<br><span class="hljs-keyword">type</span> T = Jsonify&lt;Class&gt;;<br><span class="hljs-comment">// type T = &#123;</span><br><span class="hljs-comment">//   teacher: string;</span><br><span class="hljs-comment">//   start: string;</span><br><span class="hljs-comment">//   stop: string;</span><br><span class="hljs-comment">//   students: &#123;</span><br><span class="hljs-comment">//     id: number;</span><br><span class="hljs-comment">//     name: string;</span><br><span class="hljs-comment">//     birthday: string | null;</span><br><span class="hljs-comment">//   &#125;[];</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>It does! How was TypeScript able to figure that out?</p><p>First of all, Arrays are objects, so <code>T extends object</code> is true for any array type. And <code>keyof T[]</code> includes <code>number</code>, since you can index into an array with a <code>number</code>. But it also includes methods like <code>length</code> and <code>toString</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T = keyof Student[];  <span class="hljs-comment">// type is number | "length" | "toString" | ...</span><br></code></pre></td></tr></table></figure><p>So it&#39;s a bit of a surprise <code>Jsonify</code> produces such a clean type for the array. Perhaps mapped types over arrays are special cased.</p><p>But regardless, this is great! We can even loosen the definition slightly to handle any object with a <code>toJSON()</code> method (including Dates):</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Jsonify&lt;T&gt; = T <span class="hljs-keyword">extends</span> &#123;toJSON(): infer U&#125;<br>  ? U<br>  : T <span class="hljs-keyword">extends</span> object<br>  ? &#123;<br>      [k <span class="hljs-keyword">in</span> keyof T]: Jsonify&lt;T[k]&gt;;<br>    &#125;<br>  : T;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonRoundTrip</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">x: T</span>): <span class="hljs-title">Jsonify</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(x));<br>&#125;<br><br><span class="hljs-keyword">const</span> student: Student = &#123;<br>  id: <span class="hljs-number">327</span>, name: <span class="hljs-string">'Bobby'</span>, birthday: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">'2007-10-10'</span>)<br>&#125;;<br><span class="hljs-keyword">const</span> studentRT = jsonRoundTrip(student);<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//   id: number;</span><br><span class="hljs-comment">//   name: string;</span><br><span class="hljs-comment">//   birthday: string | null;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-keyword">const</span> objWithToJSON = &#123;<br>  x: <span class="hljs-number">5</span>, y: <span class="hljs-number">6</span>, toJSON()&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.x + <span class="hljs-keyword">this</span>.y; &#125;<br>&#125;;<br><span class="hljs-keyword">const</span> objRT = jsonRoundTrip(objWithToJSON);<br><span class="hljs-comment">// type is number!</span><br></code></pre></td></tr></table></figure><p>Here we&#39;ve used the <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-inference-in-conditional-types" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-inference-in-conditional-types'); return false;">infer keyword</a> to infer the return type of the <code>toJSON</code> method of the object. Try the last example out in <a href="https://www.typescriptlang.org/play/?ssl=25&ssc=11&pln=25&pc=62#code/C4TwDgpgBAUgzgewHYEsBmIA8AVAfFAXimyggA9gIkATOKAb2ARgGUB5AOQAoBKALigokaCACcoAVQC+AKChQA-JLlQBJcpRp0EAIwBWEAMbAVS+ivnyA2gGtBSKDYggEaYgF0B8ZOizZb7rgA3BZQsvJqITJoAK5IxijIUHqISABKCHHU2KIoYDi4XGRq-LCpvgUMKqIQwDGiDqycAHRgAIaicBBcTRzNcMC5SADmvkU8PCGyQpSiaG2G0Cx11FTAVfIo1AJIMQC2OmIh8khtexACA0PDx1A6KKLAABbUbSACACJtlFAAPlC7AA2gJkskMyAGUAGMVWSGAAmWMLWhAYWwEAEYAEwAZgANACzhcoAByABCuh0IGJ+Pujxebx2EAA7lAvpQuMTMQAGLkAdgAtOiuYKucSeFIQuCkJDobDgGkSEQUsgMlkcnkuLK1pMZAB6XVQUCQQR0cz6yxogH7Q6iELmk6Ey6DIQ3PUG+S056vd5Q50jP5W4F2g2yGRSyEIFH0KDFKAAVnxPoAbPimL1eNGanUGoanig4M0yFAANS5-PNEBBMJhSUQ9YIBUo5XpTI0dVgLgIHXmo3QfNWg5iACEMiAA" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://www.typescriptlang.org/play/?ssl=25&ssc=11&pln=25&pc=62#code/C4TwDgpgBAUgzgewHYEsBmIA8AVAfFAXimyggA9gIkATOKAb2ARgGUB5AOQAoBKALigokaCACcoAVQC+AKChQA-JLlQBJcpRp0EAIwBWEAMbAVS+ivnyA2gGtBSKDYggEaYgF0B8ZOizZb7rgA3BZQsvJqITJoAK5IxijIUHqISABKCHHU2KIoYDi4XGRq-LCpvgUMKqIQwDGiDqycAHRgAIaicBBcTRzNcMC5SADmvkU8PCGyQpSiaG2G0Cx11FTAVfIo1AJIMQC2OmIh8khtexACA0PDx1A6KKLAABbUbSACACJtlFAAPlC7AA2gJkskMyAGUAGMVWSGAAmWMLWhAYWwEAEYAEwAZgANACzhcoAByABCuh0IGJ+Pujxebx2EAA7lAvpQuMTMQAGLkAdgAtOiuYKucSeFIQuCkJDobDgGkSEQUsgMlkcnkuLK1pMZAB6XVQUCQQR0cz6yxogH7Q6iELmk6Ey6DIQ3PUG+S056vd5Q50jP5W4F2g2yGRSyEIFH0KDFKAAVnxPoAbPimL1eNGanUGoanig4M0yFAANS5-PNEBBMJhSUQ9YIBUo5XpTI0dVgLgIHXmo3QfNWg5iACEMiAA'); return false;">the playground</a>. It really does return a <code>number</code>!</p><p>As TypeScript Development lead Ryan Cavanaugh once <a href="https://twitter.com/SeaRyanC/status/1029846761718702081" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://twitter.com/SeaRyanC/status/1029846761718702081'); return false;">said</a>, it&#39;s remarkable how many problems are solved by conditional types. The types involved in JSON serialization are one of them! If you produce and consume JSON in a TypeScript project, consider using something like <code>Jsonify</code> to safely handle Dates in your objects.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;If you&amp;#39;re writing a server in JavaScript, you might write an endpoint that converts an object to JSON:&lt;/p&gt;
&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs ts&quot;&gt;app.get(&lt;span class=&quot;hljs-string&quot;&gt;&#39;/user&#39;&lt;/span&gt;, &lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;request, response&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;br&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; user = getCurrentUser();&lt;br&gt;  response.json(user);&lt;br&gt;&amp;#125;);&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;On the client, you might use the &lt;code&gt;fetch&lt;/code&gt; API to hit this endpoint and deserialize (parse) the data:&lt;/p&gt;
&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs ts&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; response = &lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; fetch(&lt;span class=&quot;hljs-string&quot;&gt;&#39;/user&#39;&lt;/span&gt;);&lt;br&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; user = &lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; response.json();&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;What&amp;#39;s the relationship between the &lt;code&gt;user&lt;/code&gt; object in the server and the corresponding &lt;code&gt;user&lt;/code&gt; object in the client? And how would you model this in TypeScript?&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Item 31: Push Null Values to the Perimeter of Your Types</title>
    <link href="https://effectivetypescript.com/2020/03/24/null-values-to-perimeter/"/>
    <id>https://effectivetypescript.com/2020/03/24/null-values-to-perimeter/</id>
    <published>2020-03-24T14:05:00.000Z</published>
    <updated>2020-03-24T14:03:45.188Z</updated>
    
    <content type="html"><![CDATA[<p><em>Chapter 4 of <a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://amzn.to/38s1oCK'); return false;">Effective TypeScript</a> covers type design: the process of crafting your types to accurately model your domain. Design your types well and you&#39;ll have a happy, productive relationship with the type checker. Design them poorly and you&#39;ll find yourself constantly fighting unproductive battles with it. This item discusses a frequent source of problems in type design: where to put your <code>null</code> types.</em></p><p>When you first turn on <code>strictNullChecks</code>, it may seem as though you have to add scores of <code>if</code> statements checking for <code>null</code> and <code>undefined</code> values throughout your code. This is often because the relationships between null and non-null values are implicit: when variable A is non-null, you know that variable B is also non-null and vice versa. These implicit relationships are confusing both for human readers of your code and for the type checker.</p><p>Values are easier to work with when they&#39;re either completely null or completely non-null, rather than a mix. You can model this by pushing the null values out to the perimeter of your structures.</p><p>Suppose you want to calculate the min and max of a list of numbers. We&#39;ll call this the &quot;extent.&quot; Here&#39;s an attempt:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extent</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[]</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> min, max;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num of nums) &#123;<br>    <span class="hljs-keyword">if</span> (!min) &#123;<br>      min = num;<br>      max = num;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      min = <span class="hljs-built_in">Math</span>.min(min, num);<br>      max = <span class="hljs-built_in">Math</span>.max(max, num);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> [min, max];<br>&#125;<br></code></pre></td></tr></table></figure><p>The code type checks (without <code>strictNullChecks</code>) and has an inferred return type of <code>number[]</code>, which seems fine. But it has a bug and a design flaw:</p><ul><li>If the min or max is zero, it may get overridden. For example, <code>extent([0, 1, 2])</code> will return <code>[1, 2]</code> rather than <code>[0, 2]</code>.</li><li>If the <code>nums</code> array is empty, the function will return <code>[undefined, undefined]</code>. This sort of object with several <code>undefined</code>s will be difficult for clients to work with and is exactly the sort of type that this item discourages. We know from reading the source code that <code>min</code> and <code>max</code> will either both be <code>undefined</code> or neither, but that information isn&#39;t represented in the type system.</li></ul><p>Turning on <code>strictNullChecks</code> makes both of these issues more apparent:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extent</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[]</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> min, max;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num of nums) &#123;<br>    <span class="hljs-keyword">if</span> (!min) &#123;<br>      min = num;<br>      max = num;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      min = <span class="hljs-built_in">Math</span>.min(min, num);<br>      max = <span class="hljs-built_in">Math</span>.max(max, num);<br>                  <span class="hljs-comment">// ~~~ Argument of type 'number | undefined' is not</span><br>                  <span class="hljs-comment">//     assignable to parameter of type 'number'</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> [min, max];<br>&#125;<br></code></pre></td></tr></table></figure><p>The return type of <code>extent</code> is now inferred as <code>(number | undefined)[]</code>, which makes the design flaw more apparent. This is likely to manifest as a type error wherever you call <code>extent</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> [min, max] = extent([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]);<br><span class="hljs-keyword">const</span> span = max - min;<br>          <span class="hljs-comment">// ~~~   ~~~ Object is possibly 'undefined'</span><br></code></pre></td></tr></table></figure><p>The error in the implementation of <code>extent</code> comes about because you&#39;ve excluded <code>undefined</code> as a value for <code>min</code> but not <code>max</code>. The two are initialized together, but this information isn&#39;t present in the type system. You could make it go away by adding a check for <code>max</code>, too, but this would be doubling down on the bug.</p><p>A better solution is to put the min and max in the same object and make this object either fully <code>null</code> or fully non-<code>null</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extent</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[]</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> result: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>] | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num of nums) &#123;<br>    <span class="hljs-keyword">if</span> (!result) &#123;<br>      result = [num, num];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      result = [<span class="hljs-built_in">Math</span>.min(num, result[<span class="hljs-number">0</span>]), <span class="hljs-built_in">Math</span>.max(num, result[<span class="hljs-number">1</span>])];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>The return type is now <code>[number, number] | null</code>, which is easier for clients to work with. The min and max can be retrieved with either a non-null assertion:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> [min, max] = extent([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>])!;<br><span class="hljs-keyword">const</span> span = max - min;  <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><p>or a single check:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> range = extent([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]);<br><span class="hljs-keyword">if</span> (range) &#123;<br>  <span class="hljs-keyword">const</span> [min, max] = range;<br>  <span class="hljs-keyword">const</span> span = max - min;  <span class="hljs-comment">// OK</span><br>&#125;<br></code></pre></td></tr></table></figure><p>By using a single object to track the extent, we&#39;ve improved our design, helped TypeScript understand the relationship between null values, and fixed the bug: the <code>if (!result)</code> check is now problem free.</p><p>A mix of null and non-null values can also lead to problems in classes. For instance, suppose you have a class that represents both a user and their posts on a forum:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> UserPosts &#123;<br>  user: UserInfo | <span class="hljs-literal">null</span>;<br>  posts: Post[] | <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">this</span>.user = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">this</span>.posts = <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">async</span> init(userId: <span class="hljs-built_in">string</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all([<br>      <span class="hljs-keyword">async</span> () =&gt; <span class="hljs-keyword">this</span>.user = <span class="hljs-keyword">await</span> fetchUser(userId),<br>      <span class="hljs-keyword">async</span> () =&gt; <span class="hljs-keyword">this</span>.posts = <span class="hljs-keyword">await</span> fetchPostsForUser(userId)<br>    ]);<br>  &#125;<br><br>  getUserName() &#123;<br>    <span class="hljs-comment">// ...?</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>While the two network requests are loading, the <code>user</code> and <code>posts</code> properties will be <code>null</code>. At any time, they might both be <code>null</code>, one might be <code>null</code>, or they might both be non-<code>null</code>. There are four possibilities. This complexity will seep into every method on the class. This design is almost certain to lead to confusion, a proliferation of <code>null</code> checks, and bugs.</p><p>A better design would wait until all the data used by the class is available:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> UserPosts &#123;<br>  user: UserInfo;<br>  posts: Post[];<br><br>  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">user: UserInfo, posts: Post[]</span>) &#123;<br>    <span class="hljs-keyword">this</span>.user = user;<br>    <span class="hljs-keyword">this</span>.posts = posts;<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> init(userId: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">Promise</span>&lt;UserPosts&gt; &#123;<br>    <span class="hljs-keyword">const</span> [user, posts] = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([<br>      fetchUser(userId),<br>      fetchPostsForUser(userId)<br>    ]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserPosts(user, posts);<br>  &#125;<br><br>  getUserName() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.user.name;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Now the <code>UserPosts</code> class is fully non-<code>null</code>, and it&#39;s easy to write correct methods on it. Of course, if you need to perform operations while data is partially loaded, then you&#39;ll need to deal with the multiplicity of <code>null</code> and non-<code>null</code> states.</p><p>(Don&#39;t be tempted to replace nullable properties with Promises. This tends to lead to even more confusing code and forces all your methods to be async. Promises clarify the code that loads data but tend to have the opposite effect on the class that uses that data.)</p><h3 id="Things-to-Remember"><a href="#Things-to-Remember" class="headerlink" title="Things to Remember"></a>Things to Remember</h3><ul><li>Avoid designs in which one value being <code>null</code> or not <code>null</code> is implicitly related to another value being <code>null</code> or not <code>null</code>.</li><li>Push <code>null</code> values to the perimeter of your API by making larger objects either <code>null</code> or fully non-<code>null</code>. This will make code clearer both for human readers and for the type checker.</li><li>Consider creating a fully non-<code>null</code> class and constructing it when all values are available.</li><li>While <code>strictNullChecks</code> may flag many issues in your code, it&#39;s indispensable for surfacing the behavior of functions with respect to null values.</li></ul>]]></content>
    
    <summary type="html">
    
      When you first turn on &lt;code&gt;strictNullChecks&lt;/code&gt;, it may seem as though you have to add scores of &lt;code&gt;if&lt;/code&gt; statements checking for &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; values throughout your code. This is often because the relationships between null and non-null values are implicit: when variable A is non-null, you know that variable B is also non-null and vice versa. These implicit relationships are confusing both for human readers of your code and for the type checker.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Item 41: Understand Evolving any</title>
    <link href="https://effectivetypescript.com/2020/03/09/evolving-any/"/>
    <id>https://effectivetypescript.com/2020/03/09/evolving-any/</id>
    <published>2020-03-09T16:34:56.000Z</published>
    <updated>2020-03-09T16:32:44.839Z</updated>
    
    <content type="html"><![CDATA[<p><em>This feature was introduced way back in <a href="https://github.com/Microsoft/TypeScript/wiki/What' target=" _blank" rel="noopener" s-new-in-typescript#improved-any-inference" target="_blank" onclick="trackOutboundLink('', 'https://github.com/Microsoft/TypeScript/wiki/What' target='); return false;">TypeScript 2.1</a> in 2016. The term &quot;evolving any&quot; is not widely used outside the TypeScript compiler itself, but I find it useful to have a name for this unusual pattern.</em></p><p>In TypeScript a variable&#39;s type is generally determined when it is declared. After this, it can be <em>refined</em> (by checking if it is <code>null</code>, for instance), but it cannot expand to include new values. There is one notable exception to this, however, involving <code>any</code> types.</p><p>In JavaScript, you might write a function to generate a range of numbers like this:</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">range</span>(<span class="hljs-params">start, limit</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> out = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; limit; i++) &#123;<br>    out.push(i);<br>  &#125;<br>  <span class="hljs-keyword">return</span> out;<br>&#125;<br></code></pre></td></tr></table></figure><p>When you convert this to TypeScript, it works exactly as you&#39;d expect:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">range</span>(<span class="hljs-params">start: <span class="hljs-built_in">number</span>, limit: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> out = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; limit; i++) &#123;<br>    out.push(i);<br>  &#125;<br>  <span class="hljs-keyword">return</span> out;  <span class="hljs-comment">// Return type inferred as number[]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Upon closer inspection, however, it&#39;s surprising that this works! How does TypeScript know that the type of <code>out</code> is <code>number[]</code> when it&#39;s initialized as <code>[]</code>, which could be an array of any type?</p><p>Inspecting each of the three occurrences of <code>out</code> to reveal its inferred type starts to tell the story:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">range</span>(<span class="hljs-params">start: <span class="hljs-built_in">number</span>, limit: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> out = [];  <span class="hljs-comment">// Type is any[]</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; limit; i++) &#123;<br>    out.push(i);  <span class="hljs-comment">// Type of out is any[]</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> out;  <span class="hljs-comment">// Type is number[]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>The type of <code>out</code> starts as <code>any[]</code>, an undifferentiated array. But as we push <code>number</code> values onto it, its type &quot;evolves&quot; to become <code>number[]</code>.</p><p>This is distinct from narrowing (Item 22). An array&#39;s type can expand by pushing different elements onto it:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> result = [];  <span class="hljs-comment">// Type is any[]</span><br>result.push(<span class="hljs-string">'a'</span>);<br>result  <span class="hljs-comment">// Type is string[]</span><br>result.push(<span class="hljs-number">1</span>);<br>result  <span class="hljs-comment">// Type is (string | number)[]</span><br></code></pre></td></tr></table></figure><p>With conditionals, the type can even vary across branches. Here we show the same behavior with a simple value, rather than an array:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> val;  <span class="hljs-comment">// Type is any</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.random() &lt; <span class="hljs-number">0.5</span>) &#123;<br>  val = <span class="hljs-regexp">/hello/</span>;<br>  val  <span class="hljs-comment">// Type is RegExp</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  val = <span class="hljs-number">12</span>;<br>  val  <span class="hljs-comment">// Type is number</span><br>&#125;<br>val  <span class="hljs-comment">// Type is number | RegExp</span><br></code></pre></td></tr></table></figure><p>A final case that triggers this &quot;evolving any&quot; behavior is if a variable is initially <code>null</code>. This often comes up when you set a value in a <code>try</code>/<code>catch</code> block:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> val = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// Type is any</span><br><span class="hljs-keyword">try</span> &#123;<br>  somethingDangerous();<br>  val = <span class="hljs-number">12</span>;<br>  val  <span class="hljs-comment">// Type is number</span><br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">'alas!'</span>);<br>&#125;<br>val  <span class="hljs-comment">// Type is number | null</span><br></code></pre></td></tr></table></figure><p>Interestingly, this behavior only happens when a variable&#39;s type is implicitly <code>any</code> with <code>noImplicitAny</code> set! Adding an <em>explicit</em> <code>any</code> keeps the type constant:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> val: <span class="hljs-built_in">any</span>;  <span class="hljs-comment">// Type is any</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.random() &lt; <span class="hljs-number">0.5</span>) &#123;<br>  val = <span class="hljs-regexp">/hello/</span>;<br>  val  <span class="hljs-comment">// Type is any</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  val = <span class="hljs-number">12</span>;<br>  val  <span class="hljs-comment">// Type is any</span><br>&#125;<br>val  <span class="hljs-comment">// Type is any</span><br></code></pre></td></tr></table></figure><hr><!-- TODO: insert note icon --><p>This behavior can be confusing to follow in your editor since the type is only &quot;evolved&quot; <em>after</em> you assign or push an element. Inspecting the type on the line with the assignment will still show <code>any</code> or <code>any[]</code>.</p><hr><p>If you use a value before any assignment to it, you&#39;ll get an implicit any error:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">range</span>(<span class="hljs-params">start: <span class="hljs-built_in">number</span>, limit: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> out = [];<br>  <span class="hljs-comment">//    ~~~ Variable 'out' implicitly has type 'any[]' in some</span><br>  <span class="hljs-comment">//        locations where its type cannot be determined</span><br>  <span class="hljs-keyword">if</span> (start === limit) &#123;<br>    <span class="hljs-keyword">return</span> out;<br>    <span class="hljs-comment">//     ~~~ Variable 'out' implicitly has an 'any[]' type</span><br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; limit; i++) &#123;<br>    out.push(i);<br>  &#125;<br>  <span class="hljs-keyword">return</span> out;<br>&#125;<br></code></pre></td></tr></table></figure><p>Put another way, &quot;evolving&quot; <code>any</code> types are only <code>any</code> when you <em>write</em> to them. If you try to <em>read</em> from them while they&#39;re still <code>any</code>, you&#39;ll get an error.</p><p>Implicit <code>any</code> types do not evolve through function calls. The arrow function here trips up inference:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeSquares</span>(<span class="hljs-params">start: <span class="hljs-built_in">number</span>, limit: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> out = [];<br>     <span class="hljs-comment">// ~~~ Variable 'out' implicitly has type 'any[]' in some locations</span><br>  range(start, limit).forEach(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> &#123;<br>    out.push(i * i);<br>  &#125;);<br>  <span class="hljs-keyword">return</span> out;<br>      <span class="hljs-comment">// ~~~ Variable 'out' implicitly has an 'any[]' type</span><br>&#125;<br></code></pre></td></tr></table></figure><p>In cases like this, you may want to consider using an array&#39;s <code>map</code> and <code>filter</code> methods to build arrays in a single statement and avoid iteration and evolving <code>any</code> entirely. See Items 23 and 27.</p><p>Evolving <code>any</code> comes with all the usual caveats about type inference. Is the correct type for your array really <code>(string|number)[]</code>? Or should it be <code>number[]</code> and you incorrectly pushed a <code>string</code>? You may still want to provide an explicit type annotation to get better error checking instead of using evolving <code>any</code>.</p><h3 id="Things-to-Remember"><a href="#Things-to-Remember" class="headerlink" title="Things to Remember"></a>Things to Remember</h3><ul><li>While TypeScript types typically only <em>refine</em>, implicit <code>any</code> and <code>any[]</code> types are allowed to <em>evolve</em>. You should be able to recognize and understand this construct where it occurs.</li><li>For better error checking, consider providing an explicit type annotation instead of using evolving <code>any</code>.</li></ul>]]></content>
    
    <summary type="html">
    
      In TypeScript a variable&#39;s type is generally determined when it is declared. After this, it can be &lt;em&gt;refined&lt;/em&gt; (by checking if it is &lt;code&gt;null&lt;/code&gt;, for instance), but it cannot expand to include new values. There is one notable exception to this, however, involving &lt;code&gt;any&lt;/code&gt; types.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Welcome to Effective TypeScript!</title>
    <link href="https://effectivetypescript.com/2020/03/06/hello-world/"/>
    <id>https://effectivetypescript.com/2020/03/06/hello-world/</id>
    <published>2020-03-06T17:34:56.000Z</published>
    <updated>2020-03-12T15:40:49.361Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to the Effective TypeScript website! <a id="more"></a></p><p><a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://amzn.to/38s1oCK'); return false;"><em>Effective TypeScript</em></a> (the book) waspublished at the end of October 2019.</p><p>This companion site was a bit long in coming, but I hope to use it to:</p><ul><li>Post sample items</li><li>Post updates when TypeScript releases change the advice in the book.</li><li>Share links to conference presentations and videos.</li><li>Show examples of how to apply the items in the book.</li><li>Show general TypeScript tips &amp; tricks.</li></ul><p>An inspiration for this last one is the <a href="https://www.centauri-dreams.org/" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://www.centauri-dreams.org/'); return false;">Centauri Dreams</a> blog, which started as acompanion site for a book published in 2004 but is still going strong 16 years later.</p><p>Look for posts every ~2 weeks.</p><p>I built this site using <a href="https://hexo.io/" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://hexo.io/'); return false;">hexo</a>, a popular JavaScript-based static site generator. If you visit the <a href="https://effectivepython.com/" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://effectivepython.com/'); return false;"><em>Effective Python</em> site</a>, you&#39;ll notice a strong family resemblance. So a big thanks to <a href="https://twitter.com/haxor" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://twitter.com/haxor'); return false;">Brett</a> for that!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to the Effective TypeScript website!
    
    </summary>
    
    
    
  </entry>
  
</feed>
